<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>CHATBOT para uso de los CSV de Consumertec</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- PapaParse para procesar CSV en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      --bg:#020617;
      --card:#020617;
      --border:#1f2937;
      --accent:#22d3ee;
      --accent2:#4ade80;
      --text:#e5e7eb;
      --muted:#9ca3af;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#0f172a,#020617);
      color:var(--text);
      padding:10px;
    }
    .card{
      width:min(1100px,100%);
      max-height:96vh;
      background:var(--card);
      border-radius:20px;
      border:1px solid var(--border);
      padding:18px 20px;
      box-shadow:0 22px 50px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow-y:auto;
    }
    h1{
      font-size:1.7rem;
      text-align:center;
      margin-bottom:4px;
    }
    p{
      font-size:0.9rem;
      line-height:1.5;
      color:var(--muted);
      text-align:justify;
      text-justify:inter-word;
    }
    .section-title{
      font-size:1rem;
      font-weight:600;
      margin-bottom:4px;
      margin-top:8px;
    }
    label{
      font-size:0.85rem;
      margin-bottom:4px;
      display:block;
      color:var(--muted);
    }
    input[type="file"]{
      width:100%;
      padding:8px;
      border-radius:10px;
      border:1px dashed var(--border);
      background:#020617;
      color:var(--muted);
      font-size:0.85rem;
    }
    textarea{
      width:100%;
      min-height:90px;
      max-height:200px;
      resize:vertical;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      padding:8px 10px;
      font-size:0.85rem;
      line-height:1.4;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:6px;
      align-items:center;
    }
    .row > *{
      flex:1 1 auto;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 16px;
      border-radius:999px;
      text-decoration:none;
      border:none;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      color:#020617;
      font-weight:600;
      font-size:0.85rem;
      letter-spacing:0.02em;
      cursor:pointer;
      transition:transform 0.1s ease, filter 0.1s ease;
      white-space:nowrap;
    }
    .btn.secondary{
      background:#111827;
      color:var(--muted);
      border:1px solid var(--border);
    }
    .btn:hover{
      filter:brightness(1.06);
      transform:translateY(-1px);
    }
    .status{
      font-size:0.83rem;
      color:var(--muted);
      margin-top:4px;
    }
    .output-box{
      margin-top:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:8px 10px;
      font-size:0.83rem;
      line-height:1.45;
      max-height:260px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .small{
      font-size:0.8rem;
      color:var(--muted);
    }
    .mode-options{
      display:flex;
      gap:12px;
      margin-top:4px;
      flex-wrap:wrap;
    }
    .mode-options label{
      display:flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      font-size:0.85rem;
    }
    .mode-options input[type="radio"]{
      accent-color:#22d3ee;
      width:16px;
      height:16px;
    }
    /* Secci√≥n 6: m√°s alta y scrollbar garantizado para textos largos */
    #textOutput{
      max-height:60vh;
      overflow-y:auto;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>CHATBOT para uso de los CSV de Consumertec</h1>
    <p>
      Este chatbot est√° dise√±ado para trabajar con archivos <strong>OUTPUT_MAP_COMPARISONS.csv</strong> y
      otros CSV derivados de los experimentos de Consumertec. Primero se elige en la secci√≥n 1 uno de los
      <strong>prompts internos</strong> de an√°lisis (comparaciones, blancura, resumen general o relaci√≥n
      de RESPONSE con las dem√°s columnas). Despu√©s se sube el CSV correspondiente y se ejecuta el an√°lisis.
      El sistema genera un resumen num√©rico y una explicaci√≥n en texto continuo basada √∫nicamente en los datos
      del archivo.
    </p>

    <!-- Estado del motor (solo c√°lculo interno, sin LLM externo) -->
    <div id="llmStatus" class="status small">
      ‚ÑπÔ∏è Este chatbot utiliza √∫nicamente c√°lculos internos sobre tu CSV; no se conecta a ning√∫n modelo externo.
    </div>

    <!-- Elegir prompt interno -->
    <div>
      <div class="section-title">1. Elegir prompt interno de an√°lisis</div>
      <p class="small">
        Selecciona uno de los prompts internos. El sistema cargar√° autom√°ticamente un texto recomendado
        en la secci√≥n 3 y ajustar√° el tipo de CSV que se espera en la secci√≥n 2.
      </p>
      <div class="mode-options">
        <label>
          <input type="radio" name="mode" value="comparaciones"
                 onclick="setMode('comparaciones')" />
          Prompt 1 ‚Äî Comparaci√≥n (PRODUCT_TEST vs RESPONSE)
        </label>
        <label>
          <input type="radio" name="mode" value="whiteness"
                 onclick="setMode('whiteness')" />
          Prompt 2 ‚Äî Blancura por MONITOR (m√©tricas WI)
        </label>
        <label>
          <input type="radio" name="mode" value="resumen"
                 onclick="setMode('resumen')" />
          Prompt 3 ‚Äî Resumen general de la tabla
        </label>
        <label>
          <input type="radio" name="mode" value="response_rel"
                 onclick="setMode('response_rel')" />
          Prompt 4 ‚Äî Comparar RESPONSE con las dem√°s columnas
        </label>
      </div>
      <div class="status small" id="modeStatus">
        Despu√©s de elegir un prompt interno, se pedir√° subir el archivo CSV correcto y se cargar√° un texto
        recomendado en la secci√≥n 3.
      </div>
    </div>

    <!-- Subir CSV -->
    <div>
      <div class="section-title">2. Subir archivo CSV seg√∫n el prompt elegido</div>
      <label for="csvInput" id="csvLabel">
        Primero selecciona un prompt interno arriba. Luego podr√°s subir el CSV correspondiente.
      </label>
      <input id="csvInput" type="file" accept=".csv" />
      <div id="fileStatus" class="status">‚ö†Ô∏è Ning√∫n archivo seleccionado.</div>
    </div>

    <!-- Pregunta / Prompt -->
    <div>
      <div class="section-title">3. Prompt de an√°lisis</div>
      <label for="question">
        El prompt se rellenar√° autom√°ticamente seg√∫n el an√°lisis elegido, pero puedes editarlo libremente
        antes de ejecutar el c√°lculo.
      </label>
      <textarea id="question" placeholder="Primero elige un prompt interno para cargar aqu√≠ el texto recomendado‚Ä¶"></textarea>
      <div class="row">
        <button class="btn" type="button" onclick="analizarCSV()">
          4. Analizar CSV
        </button>
      </div>
      <div id="analysisStatus" class="status">
        ‚è≥ Esperando que elijas un prompt interno, subas el CSV correcto y uses el bot√≥n Analizar.
      </div>
    </div>

    <!-- Resultados de c√≥mputo -->
    <div>
      <div class="section-title">5. Resultados num√©ricos (resumen t√©cnico)</div>
      <div id="numericOutput" class="output-box small">
        // Aqu√≠ aparecer√°n tablas de conteos, m√°ximos por producto, etc.
      </div>
    </div>

    <!-- Explicaci√≥n en texto continuo -->
    <div>
      <div class="section-title">6. Explicaci√≥n en texto continuo (respuesta extendida)</div>
      <div id="textOutput" class="output-box">
        // Aqu√≠ se generar√° una explicaci√≥n autom√°tica extensa basada en los resultados y en tu prompt.
      </div>
    </div>
  </div>
  <!-- L√≥gica: CSV y an√°lisis interno (sin LLM) -->
  <script>
    // -------------------------------------------------------------
    // Estado global
    // -------------------------------------------------------------
    let csvFile = null;
    let csvHeaders = null;
    let analysisMode = null; // 'comparaciones', 'whiteness', 'resumen', 'response_rel'

    const whitenessMetrics = [
      "1.2.WI_STw",
      "2.2.WI_GEw",
      "3.2.WI_VOw",
      "4.2.WI_LGw"
    ];

    const csvInputEl   = document.getElementById("csvInput");
    const fileStatusEl = document.getElementById("fileStatus");
    const csvLabelEl   = document.getElementById("csvLabel");
    const modeStatusEl = document.getElementById("modeStatus");

    // -------------------------------------------------------------
    // Manejo de subida de archivo (validaci√≥n por modo)
    // -------------------------------------------------------------
    csvInputEl.addEventListener("change", (ev) => {
      const file = ev.target.files && ev.target.files[0];

      if (!analysisMode) {
        csvFile = null;
        csvHeaders = null;
        csvInputEl.value = "";
        fileStatusEl.textContent = "‚ö†Ô∏è Primero elige un prompt interno (tipo de an√°lisis).";
        return;
      }

      if (!file) {
        csvFile = null;
        csvHeaders = null;
        fileStatusEl.textContent = "‚ö†Ô∏è Ning√∫n archivo seleccionado.";
        return;
      }

      fileStatusEl.textContent =
        "‚è≥ Leyendo archivo: " + file.name + " (" + formatBytes(file.size) + ")‚Ä¶";

      Papa.parse(file, {
        header: true,
        preview: 5,
        skipEmptyLines: true,
        complete: function(results) {
          const headers = results.meta && results.meta.fields ? results.meta.fields : [];
          csvHeaders = headers;
          const valid = validarHeadersPorModo(analysisMode, headers);

          if (!valid.ok) {
            csvFile = null;
            csvInputEl.value = "";
            fileStatusEl.textContent = "‚ùå El archivo no corresponde al an√°lisis seleccionado: " + valid.mensaje;
          } else {
            csvFile = file;
            fileStatusEl.textContent = "‚úÖ Archivo v√°lido para el an√°lisis " +
              (analysisMode === "comparaciones"
                ? "de Comparaci√≥n"
                : analysisMode === "whiteness"
                  ? "de Blancura"
                  : analysisMode === "resumen"
                    ? "de Resumen general"
                    : "de RESPONSE vs otras columnas") +
              ": " + file.name + " (" + formatBytes(file.size) + ")";
          }
        },
        error: function(err) {
          csvFile = null;
          csvHeaders = null;
          csvInputEl.value = "";
          fileStatusEl.textContent = "‚ùå Error al leer el CSV: " + err;
        }
      });
    });

    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B","KB","MB","GB","TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    // -------------------------------------------------------------
    // Validaci√≥n de columnas seg√∫n modo
    // -------------------------------------------------------------
    function validarHeadersPorModo(mode, headers) {
      const hdr = headers || [];
      const set = new Set(hdr);

      if (mode === "comparaciones") {
        const needed = ["PRODUCT_TEST", "RESPONSE"];
        const faltantes = needed.filter(c => !set.has(c));
        if (faltantes.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas requeridas (" + faltantes.join(", ") +
                     "). Revisa que sea el CSV de comparaciones (PRODUCT_TEST / RESPONSE)."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "whiteness") {
        const base = ["MONITOR", "PRODUCT"];
        const faltantesBase = base.filter(c => !set.has(c));
        if (faltantesBase.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas base " + faltantesBase.join(", ") +
                     " para an√°lisis de blancura (MONITOR / PRODUCT)."
          };
        }
        const algunaMetrica = whitenessMetrics.some(m => set.has(m));
        if (!algunaMetrica) {
          return {
            ok: false,
            mensaje: "no se encontr√≥ ninguna de las m√©tricas de blancura esperadas: " +
                     whitenessMetrics.join(", ") + "."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "resumen") {
        // Acepta cualquier CSV con al menos una columna
        if (!hdr.length) {
          return { ok: false, mensaje: "el CSV no tiene columnas detectables." };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "response_rel") {
        // Necesita al menos la columna RESPONSE
        if (!set.has("RESPONSE")) {
          return {
            ok: false,
            mensaje: "no se encuentra la columna RESPONSE, necesaria para este an√°lisis."
          };
        }
        return { ok: true, mensaje: "" };
      }

      return { ok: false, mensaje: "modo de an√°lisis no reconocido." };
    }

    // -------------------------------------------------------------
    // Selecci√≥n de prompt interno (secci√≥n 1)
    // -------------------------------------------------------------
    function setModeInternal(mode) {
      analysisMode = mode;

      csvFile = null;
      csvHeaders = null;
      csvInputEl.value = "";
      fileStatusEl.textContent = "üì• Ahora sube el CSV para el an√°lisis seleccionado.";

      const questionEl = document.getElementById("question");
      questionEl.placeholder =
        "Prompt oficial cargado para el an√°lisis elegido. Puedes ajustarlo si lo deseas‚Ä¶";

      if (mode === "comparaciones") {
        questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv para identificar cu√°l es el producto con mejor desempe√±o general. Para ello, toma en cuenta √∫nicamente las comparaciones en las que la columna RESPONSE tenga los valores 01.SUPERIOR o 02.SUPERIOR_TREND, que indican un resultado favorable para PRODUCT_TEST frente a PRODUCT_BENCH. Eval√∫a cu√°ntas veces cada valor de PRODUCT_TEST alcanza un resultado superior en todas las combinaciones posibles de las columnas MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. El producto que m√°s veces obtenga resultados favorables seg√∫n estos dos valores de RESPONSE debe ser considerado como el de mejor desempe√±o. La conclusi√≥n debe presentarse en texto continuo, indicando claramente cu√°l es el producto con mejor rendimiento y por qu√©, bas√°ndose en la frecuencia con la que obtiene un desempe√±o superior en las comparaciones.`;
      } else if (mode === "whiteness") {
        questionEl.value =
`Para cada uno de los valores √∫nicos de la columna "MONITOR", identifica cu√°les son los productos ("PRODUCT") que presentan los valores m√°s altos en cada una de las m√©tricas de blancura: "1.2.WI_STw" (blancura est√°ndar), "2.2.WI_GEw" (blancura verdosa), "3.2.WI_VOw" (blancura viol√°cea) y "4.2.WI_LGw" (blancura luminosa). Para cada caso, indica en qu√© combinaciones espec√≠ficas de las variables "MODALITY", "SCENARIOS", "WASH" y "PROCESS" se presentan esos valores m√°ximos. Luego, compara entre los distintos productos dentro de cada tipo de monitor, resaltando si alg√∫n producto se destaca de forma consistente en m√°s de una m√©trica o en m√∫ltiples combinaciones. Finalmente, resume qu√© productos muestran un mejor desempe√±o global de blancura en funci√≥n del tipo de monitor utilizado, considerando la frecuencia con la que aparecen con los valores m√°s altos y la diversidad de condiciones en las que lo hacen.`;
      } else if (mode === "resumen") {
        questionEl.value =
`Haz un resumen general de la tabla del CSV, describiendo cu√°ntas filas y columnas contiene, qu√© tipo de informaci√≥n parece dominar (columnas num√©ricas frente a categ√≥ricas) y c√≥mo se distribuyen los valores. Menciona, de forma interpretativa, cu√°les son las columnas que parecen m√°s relevantes o m√°s variadas y qu√© patrones generales se pueden intuir solamente a partir de los recuentos y de los rangos de valores. La explicaci√≥n debe ir en texto continuo, sin listas, destacando las ideas principales sobre la estructura y el contenido de la tabla.`;
      } else if (mode === "response_rel") {
        questionEl.value =
`Compara la distribuci√≥n de los valores de la columna RESPONSE con lo que ocurre en el resto de columnas del CSV. Identifica qu√© valores de RESPONSE son m√°s frecuentes y, para cada uno de ellos, describe qu√© patrones se observan en las columnas principales (productos, monitores, modalidades, escenarios, procesos, etc.). Explica de forma narrativa si hay combinaciones de valores que aparezcan m√°s asociadas a determinados resultados de RESPONSE, resaltando las tendencias m√°s claras que puedan deducirse √∫nicamente de los recuentos.`;
      }

      let modoTexto = "";
      if (mode === "comparaciones") modoTexto = "Comparaci√≥n PRODUCT_TEST vs RESPONSE.";
      else if (mode === "whiteness") modoTexto = "Blancura por MONITOR (m√©tricas WI).";
      else if (mode === "resumen") modoTexto = "Resumen general de la tabla.";
      else if (mode === "response_rel") modoTexto = "Comparar RESPONSE con las dem√°s columnas.";

      modeStatusEl.textContent =
        "‚úÖ Prompt interno seleccionado: " + modoTexto;
      csvLabelEl.textContent =
        "Sube ahora el CSV correspondiente al an√°lisis seleccionado.";
    }

    window.setMode = setModeInternal;
    // -------------------------------------------------------------
    // Bot√≥n principal: analizar CSV
    // -------------------------------------------------------------
    function analizarCSVInternal() {
      const statusEl = document.getElementById("analysisStatus");
      const numericEl = document.getElementById("numericOutput");
      const textEl = document.getElementById("textOutput");
      const question = document.getElementById("question").value.trim();

      if (!analysisMode) {
        statusEl.textContent = "‚ö†Ô∏è Primero elige un prompt interno (tipo de an√°lisis).";
        return;
      }
      if (!csvFile) {
        statusEl.textContent = "‚ö†Ô∏è Sube el archivo CSV correcto para el an√°lisis seleccionado.";
        return;
      }

      statusEl.textContent = "‚è≥ Analizando CSV en modo: " +
        (analysisMode === "whiteness"
          ? "BLANCURA"
          : analysisMode === "comparaciones"
            ? "COMPARACIONES"
            : analysisMode === "resumen"
              ? "RESUMEN GENERAL"
              : "RESPONSE vs OTRAS COLUMNAS") + "‚Ä¶";

      numericEl.textContent = "// Procesando CSV, esto puede tardar para archivos grandes‚Ä¶";
      textEl.textContent = "// Preparando explicaci√≥n‚Ä¶";

      if (analysisMode === "whiteness") {
        analizarBlancura(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "comparaciones") {
        analizarComparaciones(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "resumen") {
        analizarResumen(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "response_rel") {
        analizarResponseVsOtros(statusEl, numericEl, textEl, question);
      }
    }

    window.analizarCSV = analizarCSVInternal;

    // -------------------------------------------------------------
    // Modo 1: Comparaciones PRODUCT_TEST vs RESPONSE
    // -------------------------------------------------------------
    function analizarComparaciones(statusEl, numericEl, textEl, userPrompt) {
      const objetivos = new Set(["01.SUPERIOR", "02.SUPERIOR_TREND"]);
      const conteos = {};
      let totalFilas = 0;
      let totalFiltradas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const resp = (row["RESPONSE"] || "").trim();
            if (objetivos.has(resp)) {
              totalFiltradas++;
              const ptest = (row["PRODUCT_TEST"] || "").trim() || "(VAC√çO)";
              conteos[ptest] = (conteos[ptest] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (Object.keys(conteos).length === 0) {
            statusEl.textContent = "‚ùå No se encontraron filas con RESPONSE = 01.SUPERIOR o 02.SUPERIOR_TREND.";
            numericEl.textContent = "// Sin resultados favorables para PRODUCT_TEST.";
            textEl.textContent = "// No hay suficientes datos favorables para generar una conclusi√≥n.";
            return;
          }

          const ordenados = Object.entries(conteos).sort((a,b) => b[1] - a[1]);
          const totalFavorables = ordenados.reduce((s, [,c]) => s + c, 0);

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n";
          numTxt += "Filas con RESPONSE en {01.SUPERIOR, 02.SUPERIOR_TREND}: " + totalFiltradas + "\n\n";
          numTxt += "Conteo de resultados favorables por PRODUCT_TEST:\n";
          for (const [prod, cnt] of ordenados) {
            const pct = totalFavorables > 0 ? (cnt * 100 / totalFavorables).toFixed(2) + "%" : "‚Äì";
            numTxt += "  - " + prod + ": " + cnt + " (" + pct + " de los favorables)\n";
          }
          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaComparaciones(
            userPrompt,
            ordenados,
            totalFilas,
            totalFiltradas,
            totalFavorables
          );

          statusEl.textContent = "‚úÖ An√°lisis de comparaciones completado.";
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaComparaciones(
      userPrompt,
      ordenados,
      totalFilas,
      totalFiltradas,
      totalFavorables
    ) {
      const [prodGanador, cntGanador] = ordenados[0];
      const pctGanador = totalFavorables > 0 ? (cntGanador * 100 / totalFavorables).toFixed(1) : null;
      const otros = ordenados.slice(1, Math.min(6, ordenados.length));
      const promptIntro = userPrompt
        ? "La pregunta planteada por el usuario fue la siguiente: ¬´" +
          userPrompt.replace(/\s+/g, " ").trim() +
          "¬ª. A partir de esta petici√≥n, el an√°lisis se centra en estudiar el comportamiento de PRODUCT_TEST frente a PRODUCT_BENCH utilizando √∫nicamente las filas del CSV donde la respuesta indica una superioridad clara.\n\n"
        : "En este an√°lisis se ha considerado la informaci√≥n contenida en el archivo de comparaciones, enfoc√°ndose en las filas donde la respuesta indica un desempe√±o superior para PRODUCT_TEST frente a PRODUCT_BENCH.\n\n";

      let texto = "";

      texto += promptIntro;
      texto += "El archivo incluye un total de " + totalFilas + " filas, pero para evaluar el desempe√±o real de los productos se filtraron √∫nicamente aquellos casos en los que la columna RESPONSE toma los valores 01.SUPERIOR o 02.SUPERIOR_TREND. ";
      texto += "Tras este filtrado, quedaron " + totalFiltradas + " observaciones que pueden considerarse evidencias de superioridad o tendencia a la superioridad. ";
      texto += "A partir de este conjunto depurado se contabiliz√≥ cu√°ntas veces cada valor de PRODUCT_TEST aparece asociado a un resultado favorable, agrupando todos los escenarios de MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD para tener una visi√≥n global.\n\n";

      texto += "Los resultados muestran que el producto que m√°s veces alcanza un resultado favorable es ¬´" + prodGanador + "¬ª, con " + cntGanador + " ocurrencias. ";
      if (pctGanador !== null) {
        texto += "Si se compara este n√∫mero con el total de casos favorables, ¬´" + prodGanador + "¬ª concentra aproximadamente el " + pctGanador + "% de todas las situaciones en las que alg√∫n producto gana frente al benchmark. ";
      }
      texto += "Este nivel de presencia indica que ¬´" + prodGanador + "¬ª tiende a repetir este comportamiento a lo largo de diversas combinaciones de condiciones de lavado, tipo de tejido, escenario de suciedad, monitor de evaluaci√≥n y umbral de decisi√≥n.\n\n";

      if (otros.length > 0) {
        texto += "Cuando se observa el resto de productos, aparecen otras formulaciones que logran tambi√©n un n√∫mero significativo de victorias, aunque siempre por debajo de ¬´" + prodGanador + "¬ª. ";
        texto += "Entre los principales competidores se encuentran:\n\n";

        otros.forEach(([prod, cnt]) => {
          const pct = totalFavorables > 0 ? (cnt * 100 / totalFavorables).toFixed(1) : null;
          texto += "‚Ä¢ ¬´" + prod + "¬ª con " + cnt + " resultados favorables";
          if (pct !== null) {
            texto += ", lo que representa aproximadamente el " + pct + "% del total de casos favorables";
          }
          texto += ".\n";
        });
        texto += "\n";
      }

      texto += "M√°s all√° del simple conteo de victorias, es importante considerar la diversidad de contextos en los que se produce la superioridad. ";
      texto += "Cada fila corresponde a una combinaci√≥n espec√≠fica de MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. ";
      texto += "Que un producto aparezca repetidamente como superior sugiere que su formulaci√≥n es robusta frente a cambios en estas variables.\n\n";

      texto += "En resumen, considerando exclusivamente las filas en las que PRODUCT_TEST demuestra superioridad frente a PRODUCT_BENCH, ";
      texto += "el an√°lisis pone de manifiesto que ¬´" + prodGanador + "¬ª es el producto con mejor desempe√±o global en t√©rminos de frecuencia de victorias y potencial robustez a trav√©s de distintos escenarios.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 2: Blancura por MONITOR
    // -------------------------------------------------------------
    function analizarBlancura(statusEl, numericEl, textEl, userPrompt) {
      const data = {};
      let totalFilas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const monitor = (row["MONITOR"] || "").trim();
            const product = (row["PRODUCT"] || "").trim();
            if (!monitor || !product) continue;

            for (const m of whitenessMetrics) {
              if (!(m in row)) continue;
              const v = parseFloat(row[m]);
              if (Number.isNaN(v)) continue;

              if (!data[monitor]) data[monitor] = {};
              if (!data[monitor][m]) data[monitor][m] = { max: null, rows: [] };

              const entry = data[monitor][m];
              if (entry.max === null || v > entry.max) {
                entry.max = v;
                entry.rows = [{
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                }];
              } else if (v === entry.max) {
                entry.rows.push({
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                });
              }
            }
          }
        },
        complete: function() {
          if (!Object.keys(data).length) {
            statusEl.textContent = "‚ùå No se encontraron datos v√°lidos de blancura por MONITOR.";
            numericEl.textContent = "// Sin resultados de m√©tricas de blancura.";
            textEl.textContent = "// No hay suficientes datos de blancura para generar una conclusi√≥n.";
            return;
          }

          const globalCounts = {};
          for (const monitor of Object.keys(data)) {
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              for (const row of info.rows) {
                const prod = row.PRODUCT || "(VAC√çO)";
                globalCounts[prod] = (globalCounts[prod] || 0) + 1;
              }
            }
          }

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n\n";
          numTxt += "M√°ximos de blancura por MONITOR y m√©trica:\n";
          for (const monitor of Object.keys(data).sort()) {
            numTxt += "MONITOR = " + monitor + "\n";
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              numTxt += "  M√©trica: " + metric + ", valor m√°ximo: " + info.max + "\n";
              for (const row of info.rows) {
                numTxt += "    - PRODUCT = " + row.PRODUCT +
                          ", MODALITY = " + row.MODALITY +
                          ", SCENARIOS = " + row.SCENARIOS +
                          ", WASH = " + row.WASH +
                          ", PROCESS = " + row.PROCESS + "\n";
              }
            }
            numTxt += "\n";
          }

          numTxt += "Conteo global de apariciones como m√°ximo de blancura por PRODUCT:\n";
          const globalSorted = Object.entries(globalCounts).sort((a,b) => b[1] - a[1]);
          for (const [prod, cnt] of globalSorted) {
            numTxt += "  - " + prod + ": " + cnt + "\n";
          }

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaBlancura(userPrompt, data, globalSorted);

          statusEl.textContent = "‚úÖ An√°lisis de blancura completado.";
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaBlancura(userPrompt, data, globalSorted) {
      if (!globalSorted.length) {
        return "// No se pudieron construir patrones globales de blancura.";
      }
      const [prodTop, cntTop] = globalSorted[0];
      const promptIntro = userPrompt
        ? "El an√°lisis de blancura se ha guiado por la siguiente pregunta o enfoque: ¬´" +
          userPrompt.replace(/\s+/g, " ").trim() +
          "¬ª.\n\n"
        : "En este an√°lisis se ha estudiado el comportamiento de la blancura a partir de los datos del CSV.\n\n";

      let texto = "";
      texto += promptIntro;
      texto += "A partir de las m√©tricas de blancura asociadas a cada MONITOR, se identificaron los valores m√°ximos de las distintas m√©tricas WI en funci√≥n de las combinaciones de producto, modalidad de lavado, escenario de suciedad y proceso. ";
      texto += "El recuento global de apariciones como m√°ximo de blancura muestra que el producto que m√°s veces lidera es ¬´" + prodTop + "¬ª, con " + cntTop + " apariciones entre todas las combinaciones de MONITOR y m√©tricas de blancura consideradas.\n\n";

      texto += "Este patr√≥n sugiere que la formulaci√≥n asociada a ¬´" + prodTop + "¬ª tiene una capacidad notable para generar niveles elevados de blancura en condiciones variadas. ";
      texto += "Aunque otros productos tambi√©n alcanzan en ocasiones los valores m√°ximos en determinados monitores o m√©tricas, la frecuencia con la que ¬´" + prodTop + "¬ª aparece como referencia indica una ventaja global en t√©rminos de consistencia.\n\n";

      texto += "Al desglosar los resultados por monitor, se observa que cada sistema de evaluaci√≥n aporta matices distintos: algunos monitores pueden ser m√°s sensibles a diferencias de matiz verdoso o viol√°ceo, mientras que otros ponen m√°s √©nfasis en la blancura luminosa o est√°ndar. ";
      texto += "El hecho de que un mismo producto destaque repetidamente en diferentes monitores y m√©tricas refuerza la idea de una blancura percibida m√°s s√≥lida en un rango amplio de condiciones.\n\n";

      texto += "En conjunto, y siempre dentro de los l√≠mites del CSV analizado, los datos apuntan a que ¬´" + prodTop + "¬ª ofrece un mejor desempe√±o global cuando se consideran simult√°neamente los distintos monitores y las m√©tricas de blancura estudiadas. ";
      texto += "Otros productos pueden mostrar picos de rendimiento en contextos concretos, pero ninguno parece igualar la combinaci√≥n de frecuencia y diversidad de situaciones en las que ¬´" + prodTop + "¬ª se sit√∫a en la parte alta del ranking de blancura.\n";

      return texto;
    }
    // -------------------------------------------------------------
    // Modo 3: Resumen general de la tabla
    // -------------------------------------------------------------
    function analizarResumen(statusEl, numericEl, textEl, userPrompt) {
      const stats = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            for (const col of Object.keys(row)) {
              if (!stats[col]) {
                stats[col] = {
                  numericCount: 0,
                  nonNumericCount: 0,
                  sum: 0,
                  min: null,
                  max: null,
                  categories: {}
                };
              }
              const valRaw = row[col];
              if (valRaw === null || valRaw === undefined) continue;
              const val = String(valRaw).trim();
              if (val === "") continue;

              const num = parseFloat(val.replace(",", "."));
              if (!Number.isNaN(num) && val.match(/^[+-]?(\d+(\.\d+)?|\.\d+)$/)) {
                // Num√©rico "limpio"
                stats[col].numericCount++;
                stats[col].sum += num;
                if (stats[col].min === null || num < stats[col].min) stats[col].min = num;
                if (stats[col].max === null || num > stats[col].max) stats[col].max = num;
              } else {
                stats[col].nonNumericCount++;
                stats[col].categories[val] = (stats[col].categories[val] || 0) + 1;
              }
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "‚ùå No se pudo detectar estructura v√°lida en el CSV.";
            numericEl.textContent = "// Sin informaci√≥n estructural disponible.";
            textEl.textContent = "// No hay suficiente informaci√≥n para generar un resumen.";
            return;
          }

          const numCols = headersLocal.length;
          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n";
          numTxt += "Total de columnas detectadas: " + numCols + "\n\n";

          numTxt += "Resumen por columna:\n";
          headersLocal.forEach(col => {
            const s = stats[col] || {
              numericCount: 0, nonNumericCount: 0,
              sum: 0, min: null, max: null, categories: {}
            };
            const esNumerica = s.numericCount > 0 && s.nonNumericCount === 0;
            numTxt += "Columna: " + col + "\n";
            if (esNumerica) {
              const mean = s.numericCount > 0 ? (s.sum / s.numericCount) : null;
              numTxt += "  Tipo: num√©rica\n";
              numTxt += "  Valores v√°lidos: " + s.numericCount + "\n";
              if (s.min !== null && s.max !== null) {
                numTxt += "  Rango aproximado: [" + s.min + ", " + s.max + "]\n";
              }
              if (mean !== null) {
                numTxt += "  Promedio aproximado: " + mean + "\n";
              }
            } else {
              const cats = Object.entries(s.categories);
              numTxt += "  Tipo: categ√≥rica / mixta\n";
              numTxt += "  Valores no vac√≠os: " + (s.numericCount + s.nonNumericCount) + "\n";
              numTxt += "  N¬∫ de categor√≠as distintas: " + cats.length + "\n";
              if (cats.length) {
                const topCats = cats.sort((a,b) => b[1]-a[1]).slice(0,5);
                numTxt += "  Categor√≠as m√°s frecuentes:\n";
                topCats.forEach(([v,c]) => {
                  numTxt += "    - " + v + " (" + c + " ocurrencias)\n";
                });
              }
            }
            numTxt += "\n";
          });

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaResumen(
            userPrompt,
            totalFilas,
            headersLocal,
            stats
          );

          statusEl.textContent = "‚úÖ Resumen general completado.";
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaResumen(userPrompt, totalFilas, headersLocal, stats) {
      const promptIntro = userPrompt
        ? "El resumen se ha elaborado tomando como referencia la siguiente instrucci√≥n: ¬´" +
          userPrompt.replace(/\s+/g," ").trim() + "¬ª.\n\n"
        : "A continuaci√≥n se presenta un resumen general de la estructura y el contenido del CSV analizado.\n\n";

      let texto = "";
      texto += promptIntro;
      texto += "La tabla analizada contiene un total de " + totalFilas + " filas y " +
               headersLocal.length + " columnas, lo que ya sugiere un volumen de informaci√≥n suficiente como para identificar patrones y variaciones entre distintos campos.\n\n";

      // Clasificar columnas num√©ricas vs categ√≥ricas/mixtas
      const colsNumericas = [];
      const colsCateg = [];
      headersLocal.forEach(col => {
        const s = stats[col];
        if (!s) return;
        const esNumerica = s.numericCount > 0 && s.nonNumericCount === 0;
        if (esNumerica) colsNumericas.push(col);
        else colsCateg.push(col);
      });

      if (colsNumericas.length > 0) {
        texto += "En cuanto a variables num√©ricas, se identifican columnas como ";
        texto += "¬´" + colsNumericas.slice(0,4).join("¬ª, ¬´") + "¬ª";
        if (colsNumericas.length > 4) {
          texto += " y otras m√°s, que completan un conjunto de " + colsNumericas.length + " columnas de car√°cter cuantitativo. ";
        } else {
          texto += ", que en conjunto conforman el n√∫cleo de informaci√≥n num√©rica de la tabla. ";
        }
        texto += "Estas columnas permiten estimar rangos, promedios y posibles diferencias entre productos, escenarios o procesos, seg√∫n la naturaleza espec√≠fica de cada campo.\n\n";
      }

      if (colsCateg.length > 0) {
        texto += "Por el lado de las variables categ√≥ricas o mixtas, aparecen columnas como ";
        texto += "¬´" + colsCateg.slice(0,4).join("¬ª, ¬´") + "¬ª";
        if (colsCateg.length > 4) {
          texto += " y varias m√°s, que aportan etiquetas y clasificaciones clave para interpretar los resultados num√©ricos. ";
        } else {
          texto += ", que sirven como ejes de segmentaci√≥n para organizar la informaci√≥n de la tabla. ";
        }
        texto += "En estas columnas suelen concentrarse c√≥digos de producto, tipos de monitor, modalidades de lavado, escenarios de suciedad o procesos, lo que permite dividir la informaci√≥n en grupos comparables.\n\n";
      }

      texto += "Si se observa el comportamiento interno de cada columna, se aprecia que algunas presentan una gran diversidad de categor√≠as, mientras que otras se concentran en unos pocos valores recurrentes. ";
      texto += "Las columnas con muchas categor√≠as distintas pueden estar capturando una variedad amplia de situaciones o combinaciones experimentales, mientras que aquellas con pocos valores dominantes indican focos claros de inter√©s o configuraciones repetidas a lo largo del experimento.\n\n";

      texto += "En t√©rminos generales, la estructura de la tabla ofrece un equilibrio entre campos num√©ricos y categ√≥ricos, lo que facilita la construcci√≥n de indicadores agregados (promedios, m√°ximos, rangos) y, al mismo tiempo, la segmentaci√≥n por tipo de producto, monitor o escenario. ";
      texto += "Este equilibrio es especialmente √∫til en contextos de evaluaci√≥n comparativa, donde no solo importa el valor num√©rico aislado, sino tambi√©n el contexto experimental en el que se obtiene.\n\n";

      texto += "De este modo, el CSV no solo act√∫a como un contenedor de resultados, sino como un mapa donde cada columna a√±ade una capa distinta de significado: unas cuantifican el desempe√±o, otras describen las condiciones de prueba y otras organizan las observaciones en familias coherentes. ";
      texto += "La combinaci√≥n de todas ellas permite construir lecturas m√°s ricas sobre el comportamiento de los productos y sobre c√≥mo cambian los resultados al modificar los distintos factores del experimento.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 4: Comparar RESPONSE con las dem√°s columnas
    // -------------------------------------------------------------
    function analizarResponseVsOtros(statusEl, numericEl, textEl, userPrompt) {
      const responseCounts = {};
      const responseColumnCounts = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            const rRaw = row["RESPONSE"];
            const resp = (rRaw === undefined || rRaw === null || String(rRaw).trim() === "")
              ? "(VAC√çO)" : String(rRaw).trim();
            responseCounts[resp] = (responseCounts[resp] || 0) + 1;

            for (const col of headersLocal) {
              if (col === "RESPONSE") continue;
              const vRaw = row[col];
              const val = (vRaw === undefined || vRaw === null || String(vRaw).trim() === "")
                ? "(VAC√çO)" : String(vRaw).trim();

              if (!responseColumnCounts[col]) responseColumnCounts[col] = {};
              if (!responseColumnCounts[col][resp]) responseColumnCounts[col][resp] = {};
              responseColumnCounts[col][resp][val] =
                (responseColumnCounts[col][resp][val] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "‚ùå No se pudo detectar estructura v√°lida en el CSV.";
            numericEl.textContent = "// Sin informaci√≥n estructural disponible.";
            textEl.textContent = "// No hay suficiente informaci√≥n para analizar RESPONSE.";
            return;
          }

          const sortedResponses = Object.entries(responseCounts).sort((a,b) => b[1]-a[1]);

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n\n";
          numTxt += "Distribuci√≥n de la columna RESPONSE:\n";
          sortedResponses.forEach(([r,c]) => {
            const pct = totalFilas > 0 ? (c*100/totalFilas).toFixed(2) + "%" : "‚Äì";
            numTxt += "  - " + r + ": " + c + " filas (" + pct + ")\n";
          });
          numTxt += "\n";

          numTxt += "Asociaciones entre RESPONSE y el resto de columnas (primeras 6 columnas distintas de RESPONSE):\n";
          const colsAnalizar = headersLocal.filter(c => c !== "RESPONSE").slice(0,6);

          const resumenColumnas = [];

          colsAnalizar.forEach(col => {
            const byResp = responseColumnCounts[col] || {};
            numTxt += "\nColumna: " + col + "\n";
            const perResponseTop = {};
            sortedResponses.forEach(([resp, _cntR]) => {
              const mapaValores = byResp[resp];
              if (!mapaValores) return;
              const sortedVals = Object.entries(mapaValores).sort((a,b) => b[1]-a[1]).slice(0,3);
              if (!sortedVals.length) return;
              perResponseTop[resp] = sortedVals;

              numTxt += "  RESPONSE = " + resp + ":\n";
              sortedVals.forEach(([v,c]) => {
                numTxt += "    - " + v + " (" + c + " filas)\n";
              });
            });
            resumenColumnas.push({ columna: col, perResponseTop });
          });

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaResponseRel(
            userPrompt,
            totalFilas,
            sortedResponses,
            resumenColumnas
          );

          statusEl.textContent = "‚úÖ An√°lisis RESPONSE vs otras columnas completado.";
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaResponseRel(
      userPrompt,
      totalFilas,
      sortedResponses,
      resumenColumnas
    ) {
      const promptIntro = userPrompt
        ? "El an√°lisis de la relaci√≥n entre RESPONSE y el resto de columnas se ha guiado por la instrucci√≥n: ¬´" +
          userPrompt.replace(/\s+/g," ").trim() + "¬ª.\n\n"
        : "En este apartado se explora c√≥mo se distribuye RESPONSE y qu√© asociaciones se observan con las dem√°s columnas del CSV.\n\n";

      let texto = "";
      texto += promptIntro;

      if (!sortedResponses.length) {
        texto += "En la pr√°ctica, no se han encontrado valores informativos en la columna RESPONSE, por lo que no es posible establecer patrones claros frente al resto de columnas.\n";
        return texto;
      }

      const [respTop, cntTop] = sortedResponses[0];
      const pctTop = totalFilas > 0 ? (cntTop*100/totalFilas).toFixed(1) : null;

      texto += "Al observar la distribuci√≥n general, la columna RESPONSE se reparte en varios valores posibles, pero el que domina con mayor peso es ¬´" + respTop + "¬ª, que re√∫ne " + cntTop + " filas";
      if (pctTop !== null) {
        texto += ", lo que equivale aproximadamente al " + pctTop + "% del total de registros";
      }
      texto += ". El resto de valores de RESPONSE aparece con menor frecuencia, conformando una cola de resultados menos habituales que tambi√©n contribuyen a matizar la lectura global.\n\n";

      if (sortedResponses.length > 1) {
        const segundas = sortedResponses.slice(1,3);
        if (segundas.length) {
          texto += "Adem√°s de este valor dominante, se identifican otros resultados de RESPONSE que, aunque menos frecuentes, re√∫nen un n√∫mero apreciable de casos. ";
          texto += "Entre ellos destacan ";
          texto += segundas.map(([r,c]) => "¬´" + r + "¬ª (" + c + " filas)").join(" y ");
          texto += ", que completan el mapa de respuestas posibles en el experimento.\n\n";
        }
      }

      if (!resumenColumnas.length) {
        texto += "Al relacionar RESPONSE con el resto de columnas, no se han encontrado patrones suficientemente claros como para destacar asociaciones espec√≠ficas, posiblemente debido a la dispersi√≥n de los datos o a la diversidad de valores. ";
        texto += "Aun as√≠, la distribuci√≥n global de RESPONSE ya permite intuir qu√© resultados se repiten con mayor insistencia en el conjunto de ensayos.\n";
        return texto;
      }

      texto += "Cuando se cruza RESPONSE con otras columnas clave de la tabla, comienzan a aparecer patrones m√°s concretos. ";
      texto += "Cada columna act√∫a como un eje de segmentaci√≥n que permite ver qu√© combinaciones de valores se repiten con mayor frecuencia para cada tipo de respuesta.\n\n";

      const columnasComentadas = resumenColumnas.slice(0,3);
      columnasComentadas.forEach(colInfo => {
        const colName = colInfo.columna;
        const perResponseTop = colInfo.perResponseTop || {};
        texto += "En la columna ¬´" + colName + "¬ª, las distribuciones por RESPONSE muestran que:\n";

        const respuestasComentadas = Object.entries(perResponseTop).slice(0,2);
        if (!respuestasComentadas.length) {
          texto += "  No se observan concentraciones claras asociadas a valores espec√≠ficos de RESPONSE en esta columna.\n\n";
          return;
        }

        respuestasComentadas.forEach(([respVal, topVals]) => {
          if (!topVals || !topVals.length) return;
          const lista = topVals.map(([v,c]) => "¬´" + v + "¬ª (" + c + " filas)").join(", ");
          texto += "  Para RESPONSE = ¬´" + respVal + "¬ª predominan valores como " + lista + ".\n";
        });
        texto += "\n";
      });

      texto += "En conjunto, estas asociaciones no deben interpretarse como relaciones causales directas, pero s√≠ como indicios de que ciertos contextos (definidos por productos, monitores, modalidades o escenarios) tienden a coincidir con determinados resultados de RESPONSE con mayor frecuencia que otros. ";
      texto += "Esto convierte a RESPONSE en una especie de indicador de salida que resume el efecto combinado de todas esas columnas, y a los patrones detectados en un punto de partida √∫til para explorar con m√°s detalle qu√© configuraciones experimentales est√°n detr√°s de los mejores y peores desempe√±os.\n";

      return texto;
    }
  </script>
</body>
</html>
