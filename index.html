<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>CHATBOT para uso de los CSV de Consumertec</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- PapaParse para procesar CSV en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Chart.js para los gr√°ficos de la secci√≥n 7 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <!-- jsPDF para generar el PDF de las secciones 6 y 7 -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    :root{
      --bg:#020617;
      --card:#020617;
      --border:#1f2937;
      --accent:#22d3ee;
      --accent2:#4ade80;
      --text:#e5e7eb;
      --muted:#9ca3af;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#0f172a,#020617);
      color:var(--text);
      padding:10px;
    }
    .card{
      width:min(1100px,100%);
      max-height:96vh;
      background:var(--card);
      border-radius:20px;
      border:1px solid var(--border);
      padding:18px 20px;
      box-shadow:0 22px 50px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow-y:auto;
    }
    h1{
      font-size:1.7rem;
      text-align:center;
      margin-bottom:4px;
    }
    p{
      font-size:0.9rem;
      line-height:1.5;
      color:var(--muted);
      text-align:justify;
      text-justify:inter-word;
    }
    .section-title{
      font-size:1rem;
      font-weight:600;
      margin-bottom:4px;
      margin-top:8px;
    }
    label{
      font-size:0.85rem;
      margin-bottom:4px;
      display:block;
      color:var(--muted);
    }
    input[type="file"]{
      width:100%;
      padding:8px;
      border-radius:10px;
      border:1px dashed var(--border);
      background:#020617;
      color:var(--muted);
      font-size:0.85rem;
    }
    /* NUEVO: campos de texto y selects */
    input[type="text"],
    select{
      width:100%;
      padding:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      font-size:0.85rem;
    }
    textarea{
      width:100%;
      min-height:90px;
      max-height:200px;
      resize:vertical;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      padding:8px 10px;
      font-size:0.85rem;
      line-height:1.4;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:6px;
      align-items:center;
    }
    .row > *{
      flex:1 1 auto;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 16px;
      border-radius:999px;
      text-decoration:none;
      border:none;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      color:#020617;
      font-weight:600;
      font-size:0.85rem;
      letter-spacing:0.02em;
      cursor:pointer;
      transition:transform 0.1s ease, filter 0.1s ease;
      white-space:nowrap;
    }
    .btn.secondary{
      background:#111827;
      color:var(--muted);
      border:1px solid var(--border);
    }
    .btn:hover{
      filter:brightness(1.06);
      transform:translateY(-1px);
    }
    .status{
      font-size:0.83rem;
      color:var(--muted);
      margin-top:4px;
    }
    .output-box{
      margin-top:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:8px 10px;
      font-size:0.83rem;
      line-height:1.45;
      max-height:260px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .small{
      font-size:0.8rem;
      color:var(--muted);
    }
    .mode-options{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:4px;
      flex-wrap:wrap;
    }
    .mode-group{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
    }
    .mode-group.hidden{
      display:none;
    }
    .mode-group.disabled{
      opacity:0.3;
      pointer-events:none;
    }
    .mode-options label{
      display:flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      font-size:0.85rem;
    }
    .mode-options input[type="radio"]{
      accent-color:#22d3ee;
      width:16px;
      height:16px;
    }
    /* Secci√≥n 6: m√°s alta y scrollbar garantizado para textos largos */
    #textOutput{
      max-height:60vh;
      overflow-y:auto;
    }
    /* NUEVO: contenedor gr√°fico secci√≥n 7 */
    .chart-wrapper{
      margin-top:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:8px 10px;
      height:260px;
    }
    #chartCanvas{
      width:100%;
      height:100%;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>CHATBOT para uso de los CSV de Consumertec</h1>
    <p>
      Este chatbot est√° dise√±ado para trabajar con archivos <strong>OUTPUT_MAP_COMPARISONS.csv</strong> y
      otros CSV derivados de los experimentos de Consumertec. Primero se <strong>sube en la secci√≥n 1</strong>
      el archivo CSV que se desea analizar. A partir de su estructura, en la <strong>secci√≥n 2</strong> se
      activan los <strong>prompts internos</strong> compatibles (comparaciones, blancura, resumen general,
      relaci√≥n de RESPONSE con las dem√°s columnas o sus variantes avanzadas). Despu√©s se ejecuta el an√°lisis:
      el sistema genera un <strong>resumen num√©rico en el navegador (secci√≥n 5)</strong> y, con ese resumen
      m√°s tu prompt de an√°lisis, se llama a un <strong>LLM en Hugging Face</strong> para construir la
      explicaci√≥n extensa en la <strong>secci√≥n 6</strong>.
    </p>

    <!-- Estado del motor -->
    <div id="llmStatus" class="status small">
      ‚ÑπÔ∏è El an√°lisis num√©rico se hace en el navegador (secci√≥n 5) y siempre se env√≠a el resumen num√©rico
      junto con tu prompt de an√°lisis a un backend LLM en Hugging Face para generar la secci√≥n 6.
    </div>

    <!-- Subir CSV (SECCI√ìN 1) -->
    <div>
      <div class="section-title">1. Subir archivo CSV</div>
      <label for="csvInput" id="csvLabel">
        Sube primero el CSV que quieres analizar. Seg√∫n sus columnas, se activar√°n las opciones de an√°lisis en la secci√≥n 2.
      </label>
      <input id="csvInput" type="file" accept=".csv" />
      <div id="fileStatus" class="status">‚ö†Ô∏è Ning√∫n archivo seleccionado.</div>
    </div>

    <!-- Elegir tipo de an√°lisis + prompt interno (SECCI√ìN 2) -->
    <div>
      <div class="section-title">2. Elegir tipo de an√°lisis y prompt interno</div>
      <p class="small">
        Despu√©s de subir el CSV, se mostrar√°n aqu√≠ los tipos de an√°lisis compatibles. Cada tipo activa sus
        prompts internos. El prompt seleccionado se mostrar√° en la <strong>secci√≥n 3</strong> (puedes editarlo)
        y se usar√° junto con el resumen num√©rico como entrada para el LLM que genera la explicaci√≥n de la
        <strong>secci√≥n 6</strong>.
      </p>

      <div class="mode-options">
        <!-- Grupo Comparaciones -->
        <div id="group_comparaciones" class="mode-group hidden">
          <label>
            <input id="mode_comparaciones_basico" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_basico')" />
            Prompt 1 ‚Äî Comparaci√≥n (PRODUCT_TEST vs RESPONSE)
          </label>
          <label>
            <input id="mode_comparaciones_escenarios" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_escenarios')" />
            Prompt 5 ‚Äî Comparaci√≥n por escenarios y modalidades
          </label>
        </div>

        <!-- Grupo Blancura -->
        <div id="group_whiteness" class="mode-group hidden">
          <label>
            <input id="mode_whiteness_basico" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_basico')" />
            Prompt 2 ‚Äî Blancura por MONITOR (m√©tricas WI)
          </label>
          <label>
            <input id="mode_whiteness_productos" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_productos')" />
            Prompt 6 ‚Äî Perfil de blancura por producto
          </label>
        </div>

        <!-- Grupo Resumen -->
        <div id="group_resumen" class="mode-group hidden">
          <label>
            <input id="mode_resumen_basico" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_basico')" />
            Prompt 3 ‚Äî Resumen general de la tabla
          </label>
          <label>
            <input id="mode_resumen_avanzado" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_avanzado')" />
            Prompt 7 ‚Äî Resumen avanzado y bloques de variables
          </label>
        </div>

        <!-- Grupo RESPONSE vs otras columnas -->
        <div id="group_response_rel" class="mode-group hidden">
          <label>
            <input id="mode_response_basico" type="radio" name="mode"
                   onclick="setMode('response_rel','response_basico')" />
            Prompt 4 ‚Äî Comparar RESPONSE con las dem√°s columnas
          </label>
          <label>
            <input id="mode_response_extremos" type="radio" name="mode"
                   onclick="setMode('response_rel','response_extremos')" />
            Prompt 8 ‚Äî RESPONSE: mejores y peores resultados
          </label>
        </div>
      </div>

      <div class="status small" id="modeStatus">
        Primero sube un CSV en la secci√≥n 1. Luego se activar√°n aqu√≠ los tipos de an√°lisis compatibles.
      </div>
    </div>

    <!-- Pregunta / Prompt (SECCI√ìN 3) -->
    <div>
      <div class="section-title">3. Prompt de an√°lisis</div>
      <label for="question">
        El prompt se rellenar√° autom√°ticamente seg√∫n el an√°lisis elegido, pero puedes editarlo libremente.
        Este texto se enviar√° junto con el <strong>resumen num√©rico</strong> al backend LLM para generar
        la explicaci√≥n de la secci√≥n 6.
      </label>
      <textarea id="question" placeholder="Sube un CSV y elige un tipo de an√°lisis; aqu√≠ aparecer√° el prompt asociado, que podr√°s ajustar‚Ä¶"></textarea>
      <div class="row">
        <button class="btn" type="button" onclick="analizarCSV()">
          4. Analizar CSV
        </button>
      </div>
      <div id="analysisStatus" class="status">
        ‚è≥ Sube un CSV, elige un tipo de an√°lisis en la secci√≥n 2 y luego usa el bot√≥n Analizar.
      </div>
    </div>

    <!-- Resultados de c√≥mputo -->
    <div>
      <div class="section-title">5. Resultados num√©ricos (resumen t√©cnico)</div>
      <div id="numericOutput" class="output-box small">
        // Aqu√≠ aparecer√°n tablas de conteos, m√°ximos por producto, etc. (c√°lculo interno en el navegador).
      </div>
    </div>

    <!-- Explicaci√≥n en texto continuo -->
    <div>
      <div class="section-title">6. Explicaci√≥n en texto continuo (respuesta extendida)</div>
      <div id="textOutput" class="output-box">
        // Aqu√≠ se generar√° una explicaci√≥n autom√°tica extensa producida por el LLM, usando el resumen num√©rico y tu prompt de an√°lisis.
      </div>

      <!-- NUEVO: t√≠tulo para el PDF + bot√≥n de descarga -->
      <div class="row">
        <div>
          <label for="reportTitle" class="small">
            T√≠tulo del reporte (se usar√° como t√≠tulo en el PDF y en el nombre del archivo)
          </label>
          <input id="reportTitle"
                 type="text"
                 placeholder="Ejemplo: Informe de desempe√±o de productos Consumertec" />
        </div>
        <div style="flex:0 0 auto;">
          <button class="btn secondary" type="button" onclick="descargarPDF()">
            Descargar secciones 6 y 7 (.pdf)
          </button>
        </div>
      </div>
    </div>

    <!-- NUEVA SECCI√ìN 7: gr√°ficos a partir del resumen num√©rico -->
    <div>
      <div class="section-title">7. Visualizaci√≥n gr√°fica de los resultados</div>
      <p class="small">
        Estos gr√°ficos se generan autom√°ticamente a partir del resumen num√©rico de la secci√≥n 5.
        Despu√©s de ejecutar un an√°lisis, puedes elegir si ver el gr√°fico en barras o en l√≠neas.
      </p>
      <div class="row">
        <div>
          <label for="chartType">Tipo de gr√°fico</label>
          <select id="chartType" onchange="cambiarTipoGrafico()">
            <option value="bar">Barras</option>
            <option value="line">L√≠neas</option>
          </select>
        </div>
        <div id="chartStatus" class="status">
          ‚ö†Ô∏è A√∫n no hay datos para graficar. Ejecuta un an√°lisis primero.
        </div>
      </div>
      <div class="chart-wrapper">
        <canvas id="chartCanvas"></canvas>
      </div>
    </div>
  </div>
  <!-- L√≥gica: CSV + an√°lisis interno + LLM + gr√°ficos + PDF -->
  <script>
    // ============================================================
    //  Backend LLM (FastAPI en Hugging Face) para secci√≥n 6
    // ============================================================
    const BACKEND_URL = "https://alexacido-consumertec-llm.hf.space/generate_answer";

    // -------------------------------------------------------------
    // Estado global
    // -------------------------------------------------------------
    let csvFile = null;
    let csvHeaders = null;
    let analysisMode = null;       // 'comparaciones', 'whiteness', 'resumen', 'response_rel'
    let currentPromptKey = null;   // identifica el prompt espec√≠fico

    // NUEVO: estado gr√°fico (secci√≥n 7)
    let chartInstance = null;
    let lastChartData = null;      // { labels, values, datasetLabel, title, xLabel, yLabel }

    // Tipos de an√°lisis detectados como compatibles
    const tiposDisponibles = {
      comparaciones: false,
      whiteness: false,
      resumen: false,
      response_rel: false
    };

    const whitenessMetrics = [
      "1.2.WI_STw",
      "2.2.WI_GEw",
      "3.2.WI_VOw",
      "4.2.WI_LGw"
    ];

    const csvInputEl   = document.getElementById("csvInput");
    const fileStatusEl = document.getElementById("fileStatus");
    const csvLabelEl   = document.getElementById("csvLabel");
    const modeStatusEl = document.getElementById("modeStatus");

    // -------------------------------------------------------------
    // Helpers para secci√≥n 7 (gr√°ficos)
    // -------------------------------------------------------------
    function prepararDatosGrafico(data) {
      lastChartData = data || null;
      const chartStatusEl = document.getElementById("chartStatus");
      if (!lastChartData || !lastChartData.labels || !lastChartData.labels.length) {
        if (chartStatusEl) {
          chartStatusEl.textContent = "‚ö†Ô∏è No se generaron datos suficientes para graficar.";
        }
        if (chartInstance) {
          chartInstance.destroy();
          chartInstance = null;
        }
        return;
      }
      if (chartStatusEl) {
        chartStatusEl.textContent = "‚úÖ Datos listos para graficar: " +
          (lastChartData.title || "gr√°fico a partir del resumen num√©rico.");
      }
      renderChartInternal();
    }

    function renderChartInternal() {
      const canvas = document.getElementById("chartCanvas");
      const chartTypeEl = document.getElementById("chartType");
      const chartStatusEl = document.getElementById("chartStatus");

      if (!canvas || !lastChartData || !lastChartData.labels || !lastChartData.labels.length) {
        if (chartStatusEl) {
          chartStatusEl.textContent = "‚ö†Ô∏è A√∫n no hay datos para graficar. Ejecuta un an√°lisis primero.";
        }
        return;
      }

      const ctx = canvas.getContext("2d");
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }

      const tipo = chartTypeEl ? chartTypeEl.value : "bar";

      chartInstance = new Chart(ctx, {
        type: tipo,
        data: {
          labels: lastChartData.labels,
          datasets: [{
            label: lastChartData.datasetLabel || "Valores",
            data: lastChartData.values,
            fill: false
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: true },
            title: {
              display: !!lastChartData.title,
              text: lastChartData.title
            }
          },
          scales: {
            x: {
              title: {
                display: !!lastChartData.xLabel,
                text: lastChartData.xLabel
              },
              ticks: {
                autoSkip: true,
                maxRotation: 45,
                minRotation: 0
              }
            },
            y: {
              beginAtZero: true,
              title: {
                display: !!lastChartData.yLabel,
                text: lastChartData.yLabel
              }
            }
          }
        }
      });

      if (chartStatusEl) {
        chartStatusEl.textContent = "‚úÖ Gr√°fico actualizado correctamente.";
      }
    }

    function cambiarTipoGrafico() {
      renderChartInternal();
    }
    window.cambiarTipoGrafico = cambiarTipoGrafico;

    // -------------------------------------------------------------
    // Actualizar visibilidad de grupos de prompts
    // -------------------------------------------------------------
    function actualizarDisponibilidadPrompts() {
      const groupCompar = document.getElementById("group_comparaciones");
      const groupWhite  = document.getElementById("group_whiteness");
      const groupRes    = document.getElementById("group_resumen");
      const groupResp   = document.getElementById("group_response_rel");

      if (tiposDisponibles.comparaciones) groupCompar.classList.remove("hidden");
      else groupCompar.classList.add("hidden");

      if (tiposDisponibles.whiteness) groupWhite.classList.remove("hidden");
      else groupWhite.classList.add("hidden");

      if (tiposDisponibles.resumen) groupRes.classList.remove("hidden");
      else groupRes.classList.add("hidden");

      if (tiposDisponibles.response_rel) groupResp.classList.remove("hidden");
      else groupResp.classList.add("hidden");

      const activos = [];
      if (tiposDisponibles.comparaciones) activos.push("Comparaciones PRODUCT_TEST vs RESPONSE");
      if (tiposDisponibles.whiteness)     activos.push("Blancura por MONITOR (m√©tricas WI)");
      if (tiposDisponibles.resumen)      activos.push("Resumen general / avanzado");
      if (tiposDisponibles.response_rel) activos.push("RESPONSE vs otras columnas");

      if (!csvFile) {
        modeStatusEl.textContent =
          "Primero sube un CSV en la secci√≥n 1. Luego se activar√°n aqu√≠ los tipos de an√°lisis compatibles.";
      } else if (!activos.length) {
        modeStatusEl.textContent =
          "CSV cargado, pero no se detect√≥ ninguna configuraci√≥n est√°ndar. Puedes seguir usando un resumen general con el modo Resumen.";
      } else {
        modeStatusEl.textContent =
          "CSV cargado. An√°lisis disponibles: " + activos.join(" ‚Ä¢ ") +
          ". El an√°lisis num√©rico se har√° en la secci√≥n 5 y el LLM generar√° la explicaci√≥n en la 6.";
      }
    }

    // Inicial
    actualizarDisponibilidadPrompts();

    // -------------------------------------------------------------
    // Manejo de subida de archivo (detecta tipos compatibles)
    // -------------------------------------------------------------
    csvInputEl.addEventListener("change", (ev) => {
      const file = ev.target.files && ev.target.files[0];

      // Reset al cambiar de CSV
      csvFile = null;
      csvHeaders = null;
      analysisMode = null;
      currentPromptKey = null;
      document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });

      const questionEl = document.getElementById("question");
      questionEl.value = "";
      questionEl.placeholder =
        "Tras subir el CSV y elegir un tipo de an√°lisis en la secci√≥n 2, aqu√≠ se cargar√° el prompt correspondiente‚Ä¶";

      // Reset gr√°fico
      lastChartData = null;
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
      const chartStatusEl = document.getElementById("chartStatus");
      if (chartStatusEl) {
        chartStatusEl.textContent = "‚ö†Ô∏è A√∫n no hay datos para graficar. Ejecuta un an√°lisis primero.";
      }

      if (!file) {
        fileStatusEl.textContent = "‚ö†Ô∏è Ning√∫n archivo seleccionado.";
        tiposDisponibles.comparaciones = false;
        tiposDisponibles.whiteness = false;
        tiposDisponibles.resumen = false;
        tiposDisponibles.response_rel = false;
        actualizarDisponibilidadPrompts();
        return;
      }

      fileStatusEl.textContent =
        "‚è≥ Leyendo archivo: " + file.name + " (" + formatBytes(file.size) + ")‚Ä¶";

      Papa.parse(file, {
        header: true,
        preview: 5,
        skipEmptyLines: true,
        complete: function(results) {
          const headers = results.meta && results.meta.fields ? results.meta.fields : [];
          csvHeaders = headers;

          const validCompar   = validarHeadersPorModo("comparaciones", headers);
          const validWhite    = validarHeadersPorModo("whiteness", headers);
          const validResumen  = validarHeadersPorModo("resumen", headers);
          const validRespRel  = validarHeadersPorModo("response_rel", headers);

          tiposDisponibles.comparaciones = !!validCompar.ok;
          tiposDisponibles.whiteness     = !!validWhite.ok;
          tiposDisponibles.resumen       = !!validResumen.ok;
          tiposDisponibles.response_rel  = !!validRespRel.ok;

          csvFile = file;

          const disponibles = [];
          if (validCompar.ok)  disponibles.push("Comparaci√≥n PRODUCT_TEST vs RESPONSE");
          if (validWhite.ok)   disponibles.push("Blancura por MONITOR (m√©tricas WI)");
          if (validRespRel.ok) disponibles.push("RESPONSE vs otras columnas");
          if (validResumen.ok) disponibles.push("Resumen general / avanzado");

          fileStatusEl.textContent =
            "‚úÖ CSV cargado: " + file.name + " (" + formatBytes(file.size) + "). " +
            (disponibles.length
              ? "An√°lisis posibles: " + disponibles.join(" ‚Ä¢ ") + "."
              : "Puedes usar un resumen general con el modo Resumen.");

          csvLabelEl.textContent =
            "Archivo CSV cargado. Si lo deseas, puedes cambiarlo por otro. Ahora elige en la secci√≥n 2 el tipo de an√°lisis.";

          actualizarDisponibilidadPrompts();
        },
        error: function(err) {
          csvFile = null;
          csvHeaders = null;
          fileStatusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          tiposDisponibles.comparaciones = false;
          tiposDisponibles.whiteness = false;
          tiposDisponibles.resumen = false;
          tiposDisponibles.response_rel = false;
          actualizarDisponibilidadPrompts();
        }
      });
    });

    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B","KB","MB","GB","TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    // -------------------------------------------------------------
    // Validaci√≥n de columnas seg√∫n modo
    // -------------------------------------------------------------
    function validarHeadersPorModo(mode, headers) {
      const hdr = headers || [];
      const set = new Set(hdr);

      if (mode === "comparaciones") {
        const needed = ["PRODUCT_TEST", "RESPONSE"];
        const faltantes = needed.filter(c => !set.has(c));
        if (faltantes.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas requeridas (" + faltantes.join(", ") +
                     "). Revisa que sea el CSV de comparaciones (PRODUCT_TEST / RESPONSE)."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "whiteness") {
        const base = ["MONITOR", "PRODUCT"];
        const faltantesBase = base.filter(c => !set.has(c));
        if (faltantesBase.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas base " + faltantesBase.join(", ") +
                     " para an√°lisis de blancura (MONITOR / PRODUCT)."
          };
        }
        const algunaMetrica = whitenessMetrics.some(m => set.has(m));
        if (!algunaMetrica) {
          return {
            ok: false,
            mensaje: "no se encontr√≥ ninguna de las m√©tricas de blancura esperadas: " +
                     whitenessMetrics.join(", ") + "."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "resumen") {
        if (!hdr.length) {
          return { ok: false, mensaje: "el CSV no tiene columnas detectables." };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "response_rel") {
        if (!set.has("RESPONSE")) {
          return {
            ok: false,
            mensaje: "no se encuentra la columna RESPONSE, necesaria para este an√°lisis."
          };
        }
        return { ok: true, mensaje: "" };
      }

      return { ok: false, mensaje: "modo de an√°lisis no reconocido." };
    }

    // -------------------------------------------------------------
    // Selecci√≥n de prompt interno (secci√≥n 2)
    // -------------------------------------------------------------
    function setModeInternal(mode, promptKey) {
      const llmStatusEl = document.getElementById("llmStatus");
      const questionEl  = document.getElementById("question");

      if (!csvFile) {
        modeStatusEl.textContent =
          "‚ö†Ô∏è Primero sube un CSV en la secci√≥n 1. Despu√©s podr√°s elegir el tipo de an√°lisis.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      if (mode === "comparaciones" && !tiposDisponibles.comparaciones) {
        modeStatusEl.textContent =
          "‚ùå El archivo cargado no tiene las columnas necesarias para Comparaciones (PRODUCT_TEST / RESPONSE).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "whiteness" && !tiposDisponibles.whiteness) {
        modeStatusEl.textContent =
          "‚ùå El archivo cargado no corresponde a un formato de Blancura (MONITOR, PRODUCT y m√©tricas WI).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "resumen" && !tiposDisponibles.resumen) {
        modeStatusEl.textContent =
          "‚ùå El archivo no parece tener estructura v√°lida para un resumen general.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "response_rel" && !tiposDisponibles.response_rel) {
        modeStatusEl.textContent =
          "‚ùå El archivo cargado no contiene la columna RESPONSE, necesaria para este an√°lisis.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      analysisMode = mode;
      currentPromptKey = promptKey || mode;

      questionEl.placeholder =
        "Prompt oficial cargado para el an√°lisis elegido. Puedes ajustarlo si lo deseas‚Ä¶";

      // === TEXTOS DE LOS PROMPTS INTERNOS (igual que ten√≠as) ===
      if (mode === "comparaciones") {
        if (currentPromptKey === "comparaciones_basico") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv para identificar cu√°l es el producto con mejor desempe√±o general. Para ello, toma en cuenta √∫nicamente las comparaciones en las que la columna RESPONSE tenga los valores 01.SUPERIOR o 02.SUPERIOR_TREND, que indican un resultado favorable para PRODUCT_TEST frente a PRODUCT_BENCH. Eval√∫a cu√°ntas veces cada valor de PRODUCT_TEST alcanza un resultado superior en todas las combinaciones posibles de las columnas MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. El producto que m√°s veces obtenga resultados favorables seg√∫n estos dos valores de RESPONSE debe ser considerado como el de mejor desempe√±o. La conclusi√≥n debe presentarse en texto continuo, indicando claramente cu√°l es el producto con mejor rendimiento y por qu√©, bas√°ndose en la frecuencia con la que obtiene un desempe√±o superior en las comparaciones.`;
        } else if (currentPromptKey === "comparaciones_escenarios") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv poniendo el foco en c√≥mo cambia el desempe√±o de los distintos PRODUCT_TEST seg√∫n las columnas MODALITY, SCENARIOS, WASH y PROCESS. Identifica para cada una de estas columnas qu√© productos tienden a concentrar m√°s respuestas 01.SUPERIOR y 02.SUPERIOR_TREND, se√±alando si hay formulaciones especialmente fuertes en determinados escenarios o modalidades y si existen contextos donde el rendimiento se reparte de forma m√°s equilibrada. La explicaci√≥n debe ser en texto continuo, resaltando las combinaciones producto‚Äìescenario m√°s robustas y aquellas donde las diferencias entre productos parecen menos marcadas.`;
        }
      } else if (mode === "whiteness") {
        if (currentPromptKey === "whiteness_basico") {
          questionEl.value =
`Para cada uno de los valores √∫nicos de la columna "MONITOR", identifica cu√°les son los productos ("PRODUCT") que presentan los valores m√°s altos en cada una de las m√©tricas de blancura: "1.2.WI_STw" (blancura est√°ndar), "2.2.WI_GEw" (blancura verdosa), "3.2.WI_VOw" (blancura viol√°cea) y "4.2.WI_LGw" (blancura luminosa). Para cada caso, indica en qu√© combinaciones espec√≠ficas de las variables "MODALITY", "SCENARIOS", "WASH" y "PROCESS" se presentan esos valores m√°ximos. Luego, compara entre los distintos productos dentro de cada tipo de monitor, resaltando si alg√∫n producto se destaca de forma consistente en m√°s de una m√©trica o en m√∫ltiples combinaciones. Finalmente, resume qu√© productos muestran un mejor desempe√±o global de blancura en funci√≥n del tipo de monitor utilizado, considerando la frecuencia con la que aparecen con los valores m√°s altos y la diversidad de condiciones en las que lo hacen.`;
        } else if (currentPromptKey === "whiteness_productos") {
          questionEl.value =
`Utiliza los datos de blancura del CSV para construir un perfil de cada "PRODUCT" en t√©rminos de las m√©tricas "1.2.WI_STw", "2.2.WI_GEw", "3.2.WI_VOw" y "4.2.WI_LGw" a trav√©s de todos los "MONITOR" disponibles. Describe en texto continuo qu√© productos se ubican con mayor frecuencia en los valores m√°ximos de blancura, cu√°les parecen m√°s equilibrados entre varias m√©tricas y cu√°les destacan solo en una dimensi√≥n espec√≠fica (por ejemplo, m√°s verdosa o m√°s luminosa). Indica tambi√©n si hay productos que cambian mucho su posici√≥n relativa seg√∫n el monitor utilizado, y qu√© implicaciones tiene esto para la lectura global de blancura.`;
        }
      } else if (mode === "resumen") {
        if (currentPromptKey === "resumen_basico") {
          questionEl.value =
`Haz un resumen general de la tabla del CSV, describiendo cu√°ntas filas y columnas contiene, qu√© tipo de informaci√≥n parece dominar (columnas num√©ricas frente a categ√≥ricas) y c√≥mo se distribuyen los valores. Menciona, de forma interpretativa, cu√°les son las columnas que parecen m√°s relevantes o m√°s variadas y qu√© patrones generales se pueden intuir solamente a partir de los recuentos y de los rangos de valores. La explicaci√≥n debe ir en texto continuo, sin listas, destacando las ideas principales sobre la estructura y el contenido de la tabla.`;
        } else if (currentPromptKey === "resumen_avanzado") {
          questionEl.value =
`Elabora un resumen avanzado de la tabla combinando la descripci√≥n estructural (n√∫mero de filas, columnas y tipos de variables) con una lectura m√°s interpretativa de qu√© grupos de columnas parecen estar relacionados entre s√≠. Sin realizar inferencias causales, comenta qu√© bloques de variables pueden agruparse (por ejemplo, columnas de contexto experimental frente a columnas de resultados) y c√≥mo podr√≠an utilizarse en an√°lisis posteriores m√°s espec√≠ficos. La explicaci√≥n debe ser narrativa, destacando las conexiones m√°s plausibles s√≥lo a partir de la estructura y de los recuentos.`;
        }
      } else if (mode === "response_rel") {
        if (currentPromptKey === "response_basico") {
          questionEl.value =
`Compara la distribuci√≥n de los valores de la columna RESPONSE con lo que ocurre en el resto de columnas del CSV. Identifica qu√© valores de RESPONSE son m√°s frecuentes y, para cada uno de ellos, describe qu√© patrones se observan en las columnas principales (productos, monitores, modalidades, escenarios, procesos, etc.). Explica de forma narrativa si hay combinaciones de valores que aparezcan m√°s asociadas a determinados resultados de RESPONSE, resaltando las tendencias m√°s claras que puedan deducirse √∫nicamente de los recuentos.`;
        } else if (currentPromptKey === "response_extremos") {
          questionEl.value =
`Profundiza en la columna RESPONSE distinguiendo claramente entre los resultados m√°s favorables y los menos favorables. Para cada grupo (por ejemplo, valores que representan superioridad, empate o inferioridad), describe qu√© patrones se observan en las columnas de producto, monitor, modalidad y escenario. Explica en texto continuo qu√© combinaciones parecen asociarse con respuestas especialmente buenas y cu√°les tienden a concentrar los peores resultados, utilizando √∫nicamente recuentos y frecuencias obtenidos del CSV.`;
        }
      }

      let modoTexto = "";
      if (mode === "comparaciones") modoTexto = "Comparaci√≥n PRODUCT_TEST vs RESPONSE.";
      else if (mode === "whiteness") modoTexto = "Blancura por MONITOR.";
      else if (mode === "resumen") modoTexto = "Resumen general / avanzado.";
      else if (mode === "response_rel") modoTexto = "RESPONSE vs otras columnas.";

      modeStatusEl.textContent = "‚úÖ Prompt interno seleccionado: " + modoTexto;

      if (llmStatusEl) {
        llmStatusEl.textContent =
          "‚úÖ El resumen num√©rico se calcula en el navegador (secci√≥n 5) y siempre se env√≠a al backend /generate_answer junto con tu prompt para generar la secci√≥n 6.";
      }
    }

    window.setMode = setModeInternal;

    // -------------------------------------------------------------
    // Llamada al backend FastAPI /generate_answer
    // -------------------------------------------------------------
    async function pedirExplicacionDesdeBackend(userPrompt, numericSummary, mode) {
      const textEl = document.getElementById("textOutput");
      const llmStatusEl = document.getElementById("llmStatus");

      if (!textEl) return;

      const pregunta = (userPrompt || "").trim();
      const resumen  = (numericSummary || "").trim();

      textEl.textContent = "‚è≥ Llamando al backend /generate_answer‚Ä¶";

      try {
        const resp = await fetch(BACKEND_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            mode: mode || "general",
            question: pregunta,
            numeric_summary: resumen
          })
        });

        if (!resp.ok) {
          const msg = "Respuesta HTTP no OK: " + resp.status;
          console.error(msg);
          textEl.textContent =
            "‚ùå Error llamando al backend.\n" +
            msg +
            "\n\nPuedes revisar el resumen num√©rico en la secci√≥n 5 y, si lo deseas, copiarlo en tu propio an√°lisis.";
          if (llmStatusEl) {
            llmStatusEl.textContent = "‚ùå Backend /generate_answer respondi√≥ con error " + resp.status + ".";
          }
          return;
        }

        const data = await resp.json();
        const answer = (data && data.answer) ? String(data.answer).trim() : "";

        if (!answer) {
          textEl.textContent =
            "‚ö†Ô∏è El backend no devolvi√≥ una respuesta de texto utilizable.\n" +
            "Revisa el resumen num√©rico en la secci√≥n 5 para interpretar manualmente.";
          if (llmStatusEl) {
            llmStatusEl.textContent = "‚ö†Ô∏è Backend sin respuesta de texto.";
          }
        } else {
          textEl.textContent = answer;
          if (llmStatusEl) {
            llmStatusEl.textContent = "‚úÖ Respuesta generada por el backend /generate_answer (secci√≥n 6).";
          }
        }
      } catch (err) {
        console.error("Error llamando al backend:", err);
        textEl.textContent =
          "‚ùå Error de red al llamar al backend /generate_answer.\n" +
          "Revisa tu conexi√≥n o el estado del Space en Hugging Face.";
        if (llmStatusEl) {
          llmStatusEl.textContent = "‚ùå Error de red hacia el backend.";
        }
      }
    }

    // -------------------------------------------------------------
    // Bot√≥n principal: analizar CSV
    //   - SIEMPRE: secci√≥n 5 num√©rico en navegador
    //   - SIEMPRE: secci√≥n 6 LLM
    // -------------------------------------------------------------
    function analizarCSVInternal() {
      const statusEl  = document.getElementById("analysisStatus");
      const numericEl = document.getElementById("numericOutput");
      const textEl    = document.getElementById("textOutput");
      const question  = document.getElementById("question").value.trim();

      if (!csvFile) {
        statusEl.textContent = "‚ö†Ô∏è Sube primero el archivo CSV en la secci√≥n 1.";
        return;
      }

      if (!analysisMode) {
        statusEl.textContent = "‚ö†Ô∏è Elige un tipo de an√°lisis en la secci√≥n 2.";
        return;
      }

      if (!question) {
        statusEl.textContent = "‚ö†Ô∏è El prompt de an√°lisis (secci√≥n 3) no puede estar vac√≠o.";
        return;
      }

      statusEl.textContent =
        "‚è≥ Analizando CSV en el navegador y preparando env√≠o al LLM‚Ä¶";

      numericEl.textContent =
        "// Procesando CSV para generar el resumen t√©cnico‚Ä¶";
      textEl.textContent =
        "// Esperando respuesta del LLM (secci√≥n 6)‚Ä¶";

      // Reset gr√°fico antes de cada nuevo an√°lisis
      lastChartData = null;
      if (chartInstance) {
        chartInstance.destroy();
        chartInstance = null;
      }
      const chartStatusEl = document.getElementById("chartStatus");
      if (chartStatusEl) {
        chartStatusEl.textContent = "‚è≥ Preparando datos para posibles gr√°ficos‚Ä¶";
      }

      const usarBackendLLM = true;  // SIEMPRE LLM para la explicaci√≥n

      if (analysisMode === "whiteness") {
        analizarBlancura(statusEl, numericEl, textEl, question, usarBackendLLM);
      } else if (analysisMode === "comparaciones") {
        analizarComparaciones(statusEl, numericEl, textEl, question, usarBackendLLM);
      } else if (analysisMode === "resumen") {
        analizarResumen(statusEl, numericEl, textEl, question, usarBackendLLM);
      } else if (analysisMode === "response_rel") {
        analizarResponseVsOtros(statusEl, numericEl, textEl, question, usarBackendLLM);
      }
    }

    window.analizarCSV = analizarCSVInternal;

    // -------------------------------------------------------------
    // Modo 1: Comparaciones PRODUCT_TEST vs RESPONSE
    // -------------------------------------------------------------
    function analizarComparaciones(statusEl, numericEl, textEl, userPrompt, usarBackendLLM) {
      const objetivos = new Set(["01.SUPERIOR", "02.SUPERIOR_TREND"]);
      const conteos = {};
      let totalFilas = 0;
      let totalFiltradas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const resp = (row["RESPONSE"] || "").trim();
            if (objetivos.has(resp)) {
              totalFiltradas++;
              const ptest = (row["PRODUCT_TEST"] || "").trim() || "(VAC√çO)";
              conteos[ptest] = (conteos[ptest] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (Object.keys(conteos).length === 0) {
            statusEl.textContent = "‚ùå No se encontraron filas con RESPONSE = 01.SUPERIOR o 02.SUPERIOR_TREND.";
            numericEl.textContent = "// Sin resultados favorables para PRODUCT_TEST.";
            textEl.textContent = "// No hay suficientes datos favorables para generar una conclusi√≥n con el LLM.";
            prepararDatosGrafico(null);
            return;
          }

          const ordenados = Object.entries(conteos).sort((a,b) => b[1] - a[1]);
          const totalFavorables = ordenados.reduce((s, [,c]) => s + c, 0);

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n";
          numTxt += "Filas con RESPONSE en {01.SUPERIOR, 02.SUPERIOR_TREND}: " + totalFiltradas + "\n\n";
          numTxt += "Conteo de resultados favorables por PRODUCT_TEST:\n";
          for (const [prod, cnt] of ordenados) {
            const pct = totalFavorables > 0 ? (cnt * 100 / totalFavorables).toFixed(2) + "%" : "‚Äì";
            numTxt += "  - " + prod + ": " + cnt + " (" + pct + " de los favorables)\n";
          }

          // üëâ Secci√≥n 5 SIEMPRE usa este c√°lculo interno
          numericEl.textContent = numTxt;

          // üëâ Secci√≥n 7: gr√°fico de barras/l√≠neas de conteos por PRODUCT_TEST
          prepararDatosGrafico({
            labels: ordenados.map(([prod]) => prod),
            values: ordenados.map(([, cnt]) => cnt),
            datasetLabel: "Resultados favorables",
            title: "Resultados favorables por PRODUCT_TEST",
            xLabel: "PRODUCT_TEST",
            yLabel: "N√∫mero de resultados favorables"
          });

          if (usarBackendLLM) {
            pedirExplicacionDesdeBackend(userPrompt, numTxt, "comparaciones");
            statusEl.textContent = "‚úÖ An√°lisis de comparaciones num√©rico generado. Esperando respuesta del LLM en la secci√≥n 6‚Ä¶";
          }
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
          prepararDatosGrafico(null);
        }
      });
    }

    // -------------------------------------------------------------
    // Modo 2: Blancura por MONITOR
    // -------------------------------------------------------------
    function analizarBlancura(statusEl, numericEl, textEl, userPrompt, usarBackendLLM) {
      const data = {};
      let totalFilas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const monitor = (row["MONITOR"] || "").trim();
            const product = (row["PRODUCT"] || "").trim();
            if (!monitor || !product) continue;

            for (const m of whitenessMetrics) {
              if (!(m in row)) continue;
              const v = parseFloat(row[m]);
              if (Number.isNaN(v)) continue;

              if (!data[monitor]) data[monitor] = {};
              if (!data[monitor][m]) data[monitor][m] = { max: null, rows: [] };

              const entry = data[monitor][m];
              if (entry.max === null || v > entry.max) {
                entry.max = v;
                entry.rows = [{
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                }];
              } else if (v === entry.max) {
                entry.rows.push({
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                });
              }
            }
          }
        },
        complete: function() {
          if (!Object.keys(data).length) {
            statusEl.textContent = "‚ùå No se encontraron datos v√°lidos de blancura por MONITOR.";
            numericEl.textContent = "// Sin resultados de m√©tricas de blancura.";
            textEl.textContent = "// No hay suficientes datos de blancura para generar una conclusi√≥n con el LLM.";
            prepararDatosGrafico(null);
            return;
          }

          const globalCounts = {};
          for (const monitor of Object.keys(data)) {
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              for (const row of info.rows) {
                const prod = row.PRODUCT || "(VAC√çO)";
                globalCounts[prod] = (globalCounts[prod] || 0) + 1;
              }
            }
          }

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n\n";
          numTxt += "M√°ximos de blancura por MONITOR y m√©trica:\n";
          for (const monitor of Object.keys(data).sort()) {
            numTxt += "MONITOR = " + monitor + "\n";
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              numTxt += "  M√©trica: " + metric + ", valor m√°ximo: " + info.max + "\n";
              for (const row of info.rows) {
                numTxt += "    - PRODUCT = " + row.PRODUCT +
                          ", MODALITY = " + row.MODALITY +
                          ", SCENARIOS = " + row.SCENARIOS +
                          ", WASH = " + row.WASH +
                          ", PROCESS = " + row.PROCESS + "\n";
              }
            }
            numTxt += "\n";
          }

          numTxt += "Conteo global de apariciones como m√°ximo de blancura por PRODUCT:\n";
          const globalSorted = Object.entries(globalCounts).sort((a,b) => b[1] - a[1]);
          for (const [prod, cnt] of globalSorted) {
            numTxt += "  - " + prod + ": " + cnt + "\n";
          }

          // üëâ Secci√≥n 5 SIEMPRE interno
          numericEl.textContent = numTxt;

          // üëâ Secci√≥n 7: gr√°fico de apariciones como m√°ximo por PRODUCT
          prepararDatosGrafico({
            labels: globalSorted.map(([prod]) => prod),
            values: globalSorted.map(([, cnt]) => cnt),
            datasetLabel: "Apariciones como m√°ximo de blancura",
            title: "Apariciones como m√°ximo de blancura por PRODUCT",
            xLabel: "PRODUCT",
            yLabel: "N√∫mero de apariciones como m√°ximo"
          });

          if (usarBackendLLM) {
            pedirExplicacionDesdeBackend(userPrompt, numTxt, "whiteness");
            statusEl.textContent = "‚úÖ An√°lisis de blancura num√©rico generado. Esperando respuesta del LLM en la secci√≥n 6‚Ä¶";
          }
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
          prepararDatosGrafico(null);
        }
      });
    }

    // -------------------------------------------------------------
    // Modo 3: Resumen general de la tabla
    // -------------------------------------------------------------
    function analizarResumen(statusEl, numericEl, textEl, userPrompt, usarBackendLLM) {
      const stats = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            for (const col of Object.keys(row)) {
              if (!stats[col]) {
                stats[col] = {
                  numericCount: 0,
                  nonNumericCount: 0,
                  sum: 0,
                  min: null,
                  max: null,
                  categories: {}
                };
              }
              const valRaw = row[col];
              if (valRaw === null || valRaw === undefined) continue;
              const val = String(valRaw).trim();
              if (val === "") continue;

              const num = parseFloat(val.replace(",", "."));
              if (!Number.isNaN(num) && val.match(/^[+-]?(\d+(\.\d+)?|\.\d+)$/)) {
                stats[col].numericCount++;
                stats[col].sum += num;
                if (stats[col].min === null || num < stats[col].min) stats[col].min = num;
                if (stats[col].max === null || num > stats[col].max) stats[col].max = num;
              } else {
                stats[col].nonNumericCount++;
                stats[col].categories[val] = (stats[col].categories[val] || 0) + 1;
              }
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "‚ùå No se pudo detectar estructura v√°lida en el CSV.";
            numericEl.textContent = "// Sin informaci√≥n estructural disponible.";
            textEl.textContent = "// No hay suficiente informaci√≥n para generar un resumen con el LLM.";
            prepararDatosGrafico(null);
            return;
          }

          const numCols = headersLocal.length;
          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n";
          numTxt += "Total de columnas detectadas: " + numCols + "\n\n";

          numTxt += "Resumen por columna:\n";
          headersLocal.forEach(col => {
            const s = stats[col] || {
              numericCount: 0, nonNumericCount: 0,
              sum: 0, min: null, max: null, categories: {}
            };
            const esNumerica = s.numericCount > 0 && s.nonNumericCount === 0;
            numTxt += "Columna: " + col + "\n";
            if (esNumerica) {
              const mean = s.numericCount > 0 ? (s.sum / s.numericCount) : null;
              numTxt += "  Tipo: num√©rica\n";
              numTxt += "  Valores v√°lidos: " + s.numericCount + "\n";
              if (s.min !== null && s.max !== null) {
                numTxt += "  Rango aproximado: [" + s.min + ", " + s.max + "]\n";
              }
              if (mean !== null) {
                numTxt += "  Promedio aproximado: " + mean + "\n";
              }
            } else {
              const cats = Object.entries(s.categories);
              numTxt += "  Tipo: categ√≥rica / mixta\n";
              numTxt += "  Valores no vac√≠os: " + (s.numericCount + s.nonNumericCount) + "\n";
              numTxt += "  N¬∫ de categor√≠as distintas: " + cats.length + "\n";
              if (cats.length) {
                const topCats = cats.sort((a,b) => b[1]-a[1]).slice(0,5);
                numTxt += "  Categor√≠as m√°s frecuentes:\n";
                topCats.forEach(([v,c]) => {
                  numTxt += "    - " + v + " (" + c + " ocurrencias)\n";
                });
              }
            }
            numTxt += "\n";
          });

          // üëâ Secci√≥n 5 SIEMPRE el mismo resumen interno
          numericEl.textContent = numTxt;

          // üëâ Secci√≥n 7: gr√°fico simple de densidad de datos por columna
          const labels = headersLocal;
          const values = headersLocal.map(col => {
            const s = stats[col] || { numericCount: 0, nonNumericCount: 0 };
            return (s.numericCount || 0) + (s.nonNumericCount || 0);
          });
          prepararDatosGrafico({
            labels,
            values,
            datasetLabel: "Valores no vac√≠os",
            title: "Valores no vac√≠os por columna",
            xLabel: "Columnas",
            yLabel: "N√∫mero de valores no vac√≠os"
          });

          if (usarBackendLLM) {
            pedirExplicacionDesdeBackend(userPrompt, numTxt, "resumen");
            statusEl.textContent = "‚úÖ Resumen num√©rico generado. Esperando respuesta del LLM en la secci√≥n 6‚Ä¶";
          }
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
          prepararDatosGrafico(null);
        }
      });
    }

    // -------------------------------------------------------------
    // Modo 4: Comparar RESPONSE con las dem√°s columnas
    // -------------------------------------------------------------
    function analizarResponseVsOtros(statusEl, numericEl, textEl, userPrompt, usarBackendLLM) {
      const responseCounts = {};
      const responseColumnCounts = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            const rRaw = row["RESPONSE"];
            const resp = (rRaw === undefined || rRaw === null || String(rRaw).trim() === "")
              ? "(VAC√çO)" : String(rRaw).trim();
            responseCounts[resp] = (responseCounts[resp] || 0) + 1;

            for (const col of headersLocal) {
              if (col === "RESPONSE") continue;
              const vRaw = row[col];
              const val = (vRaw === undefined || vRaw === null || String(vRaw).trim() === "")
                ? "(VAC√çO)" : String(vRaw).trim();

              if (!responseColumnCounts[col]) responseColumnCounts[col] = {};
              if (!responseColumnCounts[col][resp]) responseColumnCounts[col][resp] = {};
              responseColumnCounts[col][resp][val] =
                (responseColumnCounts[col][resp][val] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "‚ùå No se pudo detectar estructura v√°lida en el CSV.";
            numericEl.textContent = "// Sin informaci√≥n estructural disponible.";
            textEl.textContent = "// No hay suficiente informaci√≥n para analizar RESPONSE con el LLM.";
            prepararDatosGrafico(null);
            return;
          }

          const sortedResponses = Object.entries(responseCounts).sort((a,b) => b[1]-a[1]);

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n\n";
          numTxt += "Distribuci√≥n de la columna RESPONSE:\n";
          sortedResponses.forEach(([r,c]) => {
            const pct = totalFilas > 0 ? (c*100/totalFilas).toFixed(2) + "%" : "‚Äì";
            numTxt += "  - " + r + ": " + c + " filas (" + pct + ")\n";
          });
          numTxt += "\n";

          numTxt += "Asociaciones entre RESPONSE y el resto de columnas (primeras 6 columnas distintas de RESPONSE):\n";
          const colsAnalizar = headersLocal.filter(c => c !== "RESPONSE").slice(0,6);

          const resumenColumnas = [];

          colsAnalizar.forEach(col => {
            const byResp = responseColumnCounts[col] || {};
            numTxt += "\nColumna: " + col + "\n";
            const perResponseTop = {};
            sortedResponses.forEach(([resp, _cntR]) => {
              const mapaValores = byResp[resp];
              if (!mapaValores) return;
              const sortedVals = Object.entries(mapaValores).sort((a,b) => b[1]-a[1]).slice(0,3);
              if (!sortedVals.length) return;
              perResponseTop[resp] = sortedVals;

              numTxt += "  RESPONSE = " + resp + ":\n";
              sortedVals.forEach(([v,c]) => {
                numTxt += "    - " + v + " (" + c + " filas)\n";
              });
            });
            resumenColumnas.push({ columna: col, perResponseTop });
          });

          // üëâ Secci√≥n 5 SIEMPRE interna
          numericEl.textContent = numTxt;

          // üëâ Secci√≥n 7: gr√°fico de distribuci√≥n de RESPONSE
          prepararDatosGrafico({
            labels: sortedResponses.map(([r]) => r),
            values: sortedResponses.map(([, c]) => c),
            datasetLabel: "N√∫mero de filas",
            title: "Distribuci√≥n de RESPONSE",
            xLabel: "Valores de RESPONSE",
            yLabel: "N√∫mero de filas"
          });

          if (usarBackendLLM) {
            pedirExplicacionDesdeBackend(userPrompt, numTxt, "response_rel");
            statusEl.textContent = "‚úÖ An√°lisis RESPONSE vs otras columnas (num√©rico) generado. Esperando respuesta del LLM en la secci√≥n 6‚Ä¶";
          }
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
          prepararDatosGrafico(null);
        }
      });
    }

    // -------------------------------------------------------------
    // NUEVO: Generar PDF con secciones 6 y 7
    // -------------------------------------------------------------
    function descargarPDF() {
      const textEl = document.getElementById("textOutput");
      const titleInput = document.getElementById("reportTitle");
      const canvas = document.getElementById("chartCanvas");

      const { jsPDF } = window.jspdf || {};
      if (!jsPDF) {
        alert("No se pudo cargar jsPDF. Verifica la conexi√≥n a internet.");
        return;
      }

      const doc = new jsPDF({ unit: "pt", format: "a4" });
      const margin = 40;
      const pageWidth = doc.internal.pageSize.getWidth();
      const pageHeight = doc.internal.pageSize.getHeight();

      const titulo = (titleInput && titleInput.value.trim())
        ? titleInput.value.trim()
        : "Reporte de an√°lisis de Consumertec";

      let y = margin + 10;

      doc.setFont("helvetica", "bold");
      doc.setFontSize(14);
      doc.text(titulo, margin, y);
      y += 24;

      // Secci√≥n 6: texto
      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);

      const contenido = textEl ? (textEl.textContent || "").trim() : "";
      const textoReporte = contenido || "Sin contenido en la secci√≥n 6.";

      const maxWidth = pageWidth - margin * 2;
      const lineas = doc.splitTextToSize(textoReporte, maxWidth);

      lineas.forEach(linea => {
        if (y > pageHeight - margin) {
          doc.addPage();
          y = margin;
        }
        doc.text(linea, margin, y);
        y += 14;
      });

      // Secci√≥n 7: gr√°fico (si existe)
      if (chartInstance && canvas) {
        const imgData = chartInstance.toBase64Image(); // PNG base64
        const imgWidth = pageWidth - margin * 2;
        const imgHeight = imgWidth * (canvas.height / canvas.width || 0.6);

        if (y + imgHeight > pageHeight - margin) {
          doc.addPage();
          y = margin;
        }

        doc.setFont("helvetica", "bold");
        doc.setFontSize(12);
        doc.text("Visualizaci√≥n gr√°fica de resultados (Secci√≥n 7)", margin, y);
        y += 18;

        doc.addImage(imgData, "PNG", margin, y, imgWidth, imgHeight);
        y += imgHeight + 10;
      }

      const fileNameSafe = titulo.replace(/[\\\/:*?"<>|]+/g, "_");
      doc.save(fileNameSafe + ".pdf");
    }

    window.descargarPDF = descargarPDF;
  </script>
</body>
</html>
