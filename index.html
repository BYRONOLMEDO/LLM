<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>CHATBOT para uso de los CSV de Consumertec</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- PapaParse para procesar CSV en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      --bg:#020617;
      --card:#020617;
      --border:#1f2937;
      --accent:#22d3ee;
      --accent2:#4ade80;
      --text:#e5e7eb;
      --muted:#9ca3af;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#0f172a,#020617);
      color:var(--text);
      padding:10px;
    }
    .card{
      width:min(1100px,100%);
      max-height:96vh;
      background:var(--card);
      border-radius:20px;
      border:1px solid var(--border);
      padding:18px 20px;
      box-shadow:0 22px 50px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow-y:auto;
    }
    h1{
      font-size:1.7rem;
      text-align:center;
      margin-bottom:4px;
    }
    p{
      font-size:0.9rem;
      line-height:1.5;
      color:var(--muted);
      text-align:justify;
      text-justify:inter-word;
    }
    .section-title{
      font-size:1rem;
      font-weight:600;
      margin-bottom:4px;
      margin-top:8px;
    }
    label{
      font-size:0.85rem;
      margin-bottom:4px;
      display:block;
      color:var(--muted);
    }
    input[type="file"]{
      width:100%;
      padding:8px;
      border-radius:10px;
      border:1px dashed var(--border);
      background:#020617;
      color:var(--muted);
      font-size:0.85rem;
    }
    textarea{
      width:100%;
      min-height:90px;
      max-height:200px;
      resize:vertical;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      padding:8px 10px;
      font-size:0.85rem;
      line-height:1.4;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:6px;
      align-items:center;
    }
    .row > *{
      flex:1 1 auto;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 16px;
      border-radius:999px;
      text-decoration:none;
      border:none;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      color:#020617;
      font-weight:600;
      font-size:0.85rem;
      letter-spacing:0.02em;
      cursor:pointer;
      transition:transform 0.1s ease, filter 0.1s ease;
      white-space:nowrap;
    }
    .btn.secondary{
      background:#111827;
      color:var(--muted);
      border:1px solid var(--border);
    }
    .btn:hover{
      filter:brightness(1.06);
      transform:translateY(-1px);
    }
    .status{
      font-size:0.83rem;
      color:var(--muted);
      margin-top:4px;
    }
    .output-box{
      margin-top:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:8px 10px;
      font-size:0.83rem;
      line-height:1.45;
      max-height:260px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .small{
      font-size:0.8rem;
      color:var(--muted);
    }
    .mode-options{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:4px;
      flex-wrap:wrap;
    }
    .mode-group{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
    }
    .mode-group.hidden{
      display:none;
    }
    .mode-group.disabled{
      opacity:0.3;
      pointer-events:none;
    }
    .mode-options label{
      display:flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      font-size:0.85rem;
    }
    .mode-options input[type="radio"]{
      accent-color:#22d3ee;
      width:16px;
      height:16px;
    }
    /* Secci√≥n 6: m√°s alta y scrollbar garantizado para textos largos */
    #textOutput{
      max-height:60vh;
      overflow-y:auto;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>CHATBOT para uso de los CSV de Consumertec</h1>
    <p>
      Este chatbot est√° dise√±ado para trabajar con archivos <strong>OUTPUT_MAP_COMPARISONS.csv</strong> y
      otros CSV derivados de los experimentos de Consumertec. Primero se <strong>sube en la secci√≥n 1</strong>
      el archivo CSV que se desea analizar. A partir de su estructura, en la <strong>secci√≥n 2</strong> se
      activan los <strong>prompts internos</strong> compatibles (comparaciones, blancura, resumen general,
      relaci√≥n de RESPONSE con las dem√°s columnas o sus variantes avanzadas). Despu√©s se ejecuta el an√°lisis:
      el sistema genera un resumen num√©rico y una explicaci√≥n en texto continuo basada en los datos.
    </p>

    <!-- Estado del motor -->
    <div id="llmStatus" class="status small">
      ‚ÑπÔ∏è El an√°lisis num√©rico se hace en el navegador. Opcionalmente, el modo <strong>Pregunta Abierta</strong>
      env√≠a el resumen num√©rico y tu pregunta a un backend LLM en Hugging Face para generar la secci√≥n 6.
    </div>

    <!-- Subir CSV (SECCI√ìN 1) -->
    <div>
      <div class="section-title">1. Subir archivo CSV</div>
      <label for="csvInput" id="csvLabel">
        Sube primero el CSV que quieres analizar. Seg√∫n sus columnas, se activar√°n las opciones de an√°lisis en la secci√≥n 2.
      </label>
      <input id="csvInput" type="file" accept=".csv" />
      <div id="fileStatus" class="status">‚ö†Ô∏è Ning√∫n archivo seleccionado.</div>
    </div>

    <!-- Elegir tipo de an√°lisis + prompt interno (SECCI√ìN 2) -->
    <div>
      <div class="section-title">2. Elegir tipo de an√°lisis y prompt interno</div>
      <p class="small">
        Despu√©s de subir el CSV, se mostrar√°n aqu√≠ los tipos de an√°lisis compatibles. Cada tipo activa sus
        prompts internos. Si prefieres <strong>Pregunta Abierta</strong>, se ignorar√°n esos prompts y se usar√°
        √∫nicamente tu texto + el resumen num√©rico para consultar el LLM conectado.
      </p>

      <div class="mode-options">
        <!-- Grupo Comparaciones -->
        <div id="group_comparaciones" class="mode-group hidden">
          <label>
            <input id="mode_comparaciones_basico" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_basico')" />
            Prompt 1 ‚Äî Comparaci√≥n (PRODUCT_TEST vs RESPONSE)
          </label>
          <label>
            <input id="mode_comparaciones_escenarios" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_escenarios')" />
            Prompt 5 ‚Äî Comparaci√≥n por escenarios y modalidades
          </label>
        </div>

        <!-- Grupo Blancura -->
        <div id="group_whiteness" class="mode-group hidden">
          <label>
            <input id="mode_whiteness_basico" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_basico')" />
            Prompt 2 ‚Äî Blancura por MONITOR (m√©tricas WI)
          </label>
          <label>
            <input id="mode_whiteness_productos" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_productos')" />
            Prompt 6 ‚Äî Perfil de blancura por producto
          </label>
        </div>

        <!-- Grupo Resumen -->
        <div id="group_resumen" class="mode-group hidden">
          <label>
            <input id="mode_resumen_basico" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_basico')" />
            Prompt 3 ‚Äî Resumen general de la tabla
          </label>
          <label>
            <input id="mode_resumen_avanzado" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_avanzado')" />
            Prompt 7 ‚Äî Resumen avanzado y bloques de variables
          </label>
        </div>

        <!-- Grupo RESPONSE vs otras columnas -->
        <div id="group_response_rel" class="mode-group hidden">
          <label>
            <input id="mode_response_basico" type="radio" name="mode"
                   onclick="setMode('response_rel','response_basico')" />
            Prompt 4 ‚Äî Comparar RESPONSE con las dem√°s columnas
          </label>
          <label>
            <input id="mode_response_extremos" type="radio" name="mode"
                   onclick="setMode('response_rel','response_extremos')" />
            Prompt 8 ‚Äî RESPONSE: mejores y peores resultados
          </label>
        </div>
      </div>

      <!-- Bot√≥n Pregunta Abierta -->
      <div class="row" style="margin-top:8px;">
        <button class="btn secondary" type="button" onclick="activarPreguntaAbierta()">
          Pregunta Abierta
        </button>
      </div>

      <div class="status small" id="modeStatus">
        Primero sube un CSV en la secci√≥n 1. Luego se activar√°n aqu√≠ los tipos de an√°lisis compatibles
        o podr√°s usar Pregunta Abierta con LLM.
      </div>
    </div>

    <!-- Pregunta / Prompt (SECCI√ìN 3) -->
    <div>
      <div class="section-title">3. Prompt de an√°lisis</div>
      <label for="question">
        El prompt se rellenar√° autom√°ticamente seg√∫n el an√°lisis elegido, pero puedes editarlo libremente.
        Si usas <strong>Pregunta Abierta</strong>, aqu√≠ escribes tu pregunta y no se carga ning√∫n prompt interno.
      </label>
      <textarea id="question" placeholder="Sube un CSV y elige un tipo de an√°lisis o pulsa Pregunta Abierta para escribir aqu√≠ tu propio texto‚Ä¶"></textarea>
      <div class="row">
        <button class="btn" type="button" onclick="analizarCSV()">
          4. Analizar CSV
        </button>
      </div>
      <div id="analysisStatus" class="status">
        ‚è≥ Sube un CSV, elige un tipo de an√°lisis en la secci√≥n 2 o activa Pregunta Abierta y luego usa el bot√≥n Analizar.
      </div>
    </div>

    <!-- Resultados de c√≥mputo -->
    <div>
      <div class="section-title">5. Resultados num√©ricos (resumen t√©cnico)</div>
      <div id="numericOutput" class="output-box small">
        // Aqu√≠ aparecer√°n tablas de conteos, m√°ximos por producto, etc.
      </div>
    </div>

    <!-- Explicaci√≥n en texto continuo -->
    <div>
      <div class="section-title">6. Explicaci√≥n en texto continuo (respuesta extendida)</div>
      <div id="textOutput" class="output-box">
        // Aqu√≠ se generar√° una explicaci√≥n autom√°tica extensa (interna o desde el LLM, seg√∫n el modo).
      </div>
    </div>
  </div>
  <!-- L√≥gica: CSV + an√°lisis interno + LLM para Pregunta Abierta -->
  <script>
    // ============================================================
    //  Backend LLM (FastAPI en Hugging Face)
    // ============================================================
    const BACKEND_URL = "https://alexacido-consumertec-llm.hf.space/generate_answer";

    // -------------------------------------------------------------
    // Estado global
    // -------------------------------------------------------------
    let csvFile = null;
    let csvHeaders = null;
    let analysisMode = null;       // 'comparaciones', 'whiteness', 'resumen', 'response_rel'
    let currentPromptKey = null;   // identifica el prompt espec√≠fico
    let openQuestionMode = false;  // Pregunta Abierta activa

    // Tipos de an√°lisis detectados como compatibles
    const tiposDisponibles = {
      comparaciones: false,
      whiteness: false,
      resumen: false,
      response_rel: false
    };

    const whitenessMetrics = [
      "1.2.WI_STw",
      "2.2.WI_GEw",
      "3.2.WI_VOw",
      "4.2.WI_LGw"
    ];

    const csvInputEl   = document.getElementById("csvInput");
    const fileStatusEl = document.getElementById("fileStatus");
    const csvLabelEl   = document.getElementById("csvLabel");
    const modeStatusEl = document.getElementById("modeStatus");

    // -------------------------------------------------------------
    // Actualizar visibilidad de grupos de prompts
    // -------------------------------------------------------------
    function actualizarDisponibilidadPrompts() {
      const groupCompar = document.getElementById("group_comparaciones");
      const groupWhite  = document.getElementById("group_whiteness");
      const groupRes    = document.getElementById("group_resumen");
      const groupResp   = document.getElementById("group_response_rel");

      if (tiposDisponibles.comparaciones) groupCompar.classList.remove("hidden");
      else groupCompar.classList.add("hidden");

      if (tiposDisponibles.whiteness) groupWhite.classList.remove("hidden");
      else groupWhite.classList.add("hidden");

      if (tiposDisponibles.resumen) groupRes.classList.remove("hidden");
      else groupRes.classList.add("hidden");

      if (tiposDisponibles.response_rel) groupResp.classList.remove("hidden");
      else groupResp.classList.add("hidden");

      const activos = [];
      if (tiposDisponibles.comparaciones) activos.push("Comparaciones PRODUCT_TEST vs RESPONSE");
      if (tiposDisponibles.whiteness)     activos.push("Blancura por MONITOR (m√©tricas WI)");
      if (tiposDisponibles.resumen)      activos.push("Resumen general / avanzado");
      if (tiposDisponibles.response_rel) activos.push("RESPONSE vs otras columnas");

      if (!csvFile) {
        modeStatusEl.textContent =
          "Primero sube un CSV en la secci√≥n 1. Luego se activar√°n aqu√≠ los tipos de an√°lisis compatibles o Pregunta Abierta.";
      } else if (!activos.length) {
        modeStatusEl.textContent =
          "CSV cargado, pero no se detect√≥ ninguna configuraci√≥n est√°ndar. Puedes seguir usando Pregunta Abierta con resumen general.";
      } else {
        modeStatusEl.textContent =
          "CSV cargado. An√°lisis disponibles: " + activos.join(" ‚Ä¢ ") +
          ". O usa Pregunta Abierta para combinar tu texto con el resumen num√©rico.";
      }
    }

    // Inicial
    actualizarDisponibilidadPrompts();

    // -------------------------------------------------------------
    // Manejo de subida de archivo (detecta tipos compatibles)
    // -------------------------------------------------------------
    csvInputEl.addEventListener("change", (ev) => {
      const file = ev.target.files && ev.target.files[0];

      // Reset al cambiar de CSV
      csvFile = null;
      csvHeaders = null;
      analysisMode = null;
      currentPromptKey = null;
      openQuestionMode = false;
      document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });

      const questionEl = document.getElementById("question");
      questionEl.value = "";
      questionEl.placeholder =
        "Tras subir el CSV y elegir un tipo de an√°lisis o Pregunta Abierta, aqu√≠ se cargar√° o escribir√°s el texto‚Ä¶";

      if (!file) {
        fileStatusEl.textContent = "‚ö†Ô∏è Ning√∫n archivo seleccionado.";
        tiposDisponibles.comparaciones = false;
        tiposDisponibles.whiteness = false;
        tiposDisponibles.resumen = false;
        tiposDisponibles.response_rel = false;
        actualizarDisponibilidadPrompts();
        return;
      }

      fileStatusEl.textContent =
        "‚è≥ Leyendo archivo: " + file.name + " (" + formatBytes(file.size) + ")‚Ä¶";

      Papa.parse(file, {
        header: true,
        preview: 5,
        skipEmptyLines: true,
        complete: function(results) {
          const headers = results.meta && results.meta.fields ? results.meta.fields : [];
          csvHeaders = headers;

          const validCompar   = validarHeadersPorModo("comparaciones", headers);
          const validWhite    = validarHeadersPorModo("whiteness", headers);
          const validResumen  = validarHeadersPorModo("resumen", headers);
          const validRespRel  = validarHeadersPorModo("response_rel", headers);

          tiposDisponibles.comparaciones = !!validCompar.ok;
          tiposDisponibles.whiteness     = !!validWhite.ok;
          tiposDisponibles.resumen       = !!validResumen.ok;
          tiposDisponibles.response_rel  = !!validRespRel.ok;

          csvFile = file;

          const disponibles = [];
          if (validCompar.ok)  disponibles.push("Comparaci√≥n PRODUCT_TEST vs RESPONSE");
          if (validWhite.ok)   disponibles.push("Blancura por MONITOR (m√©tricas WI)");
          if (validRespRel.ok) disponibles.push("RESPONSE vs otras columnas");
          if (validResumen.ok) disponibles.push("Resumen general / avanzado");

          fileStatusEl.textContent =
            "‚úÖ CSV cargado: " + file.name + " (" + formatBytes(file.size) + "). " +
            (disponibles.length
              ? "An√°lisis posibles: " + disponibles.join(" ‚Ä¢ ") + "."
              : "Puedes usar un resumen general y Pregunta Abierta.");

          csvLabelEl.textContent =
            "Archivo CSV cargado. Si lo deseas, puedes cambiarlo por otro. Ahora elige en la secci√≥n 2 el tipo de an√°lisis o Pregunta Abierta.";

          actualizarDisponibilidadPrompts();
        },
        error: function(err) {
          csvFile = null;
          csvHeaders = null;
          fileStatusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          tiposDisponibles.comparaciones = false;
          tiposDisponibles.whiteness = false;
          tiposDisponibles.resumen = false;
          tiposDisponibles.response_rel = false;
          actualizarDisponibilidadPrompts();
        }
      });
    });

    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B","KB","MB","GB","TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    // -------------------------------------------------------------
    // Validaci√≥n de columnas seg√∫n modo
    // -------------------------------------------------------------
    function validarHeadersPorModo(mode, headers) {
      const hdr = headers || [];
      const set = new Set(hdr);

      if (mode === "comparaciones") {
        const needed = ["PRODUCT_TEST", "RESPONSE"];
        const faltantes = needed.filter(c => !set.has(c));
        if (faltantes.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas requeridas (" + faltantes.join(", ") +
                     "). Revisa que sea el CSV de comparaciones (PRODUCT_TEST / RESPONSE)."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "whiteness") {
        const base = ["MONITOR", "PRODUCT"];
        const faltantesBase = base.filter(c => !set.has(c));
        if (faltantesBase.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas base " + faltantesBase.join(", ") +
                     " para an√°lisis de blancura (MONITOR / PRODUCT)."
          };
        }
        const algunaMetrica = whitenessMetrics.some(m => set.has(m));
        if (!algunaMetrica) {
          return {
            ok: false,
            mensaje: "no se encontr√≥ ninguna de las m√©tricas de blancura esperadas: " +
                     whitenessMetrics.join(", ") + "."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "resumen") {
        if (!hdr.length) {
          return { ok: false, mensaje: "el CSV no tiene columnas detectables." };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "response_rel") {
        if (!set.has("RESPONSE")) {
          return {
            ok: false,
            mensaje: "no se encuentra la columna RESPONSE, necesaria para este an√°lisis."
          };
        }
        return { ok: true, mensaje: "" };
      }

      return { ok: false, mensaje: "modo de an√°lisis no reconocido." };
    }

    // -------------------------------------------------------------
    // Selecci√≥n de prompt interno (secci√≥n 2)
    // -------------------------------------------------------------
    function setModeInternal(mode, promptKey) {
      const llmStatusEl = document.getElementById("llmStatus");
      const questionEl  = document.getElementById("question");

      // Al elegir modo interno, desactivar Pregunta Abierta
      openQuestionMode = false;

      if (!csvFile) {
        modeStatusEl.textContent =
          "‚ö†Ô∏è Primero sube un CSV en la secci√≥n 1. Despu√©s podr√°s elegir el tipo de an√°lisis.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      if (mode === "comparaciones" && !tiposDisponibles.comparaciones) {
        modeStatusEl.textContent =
          "‚ùå El archivo cargado no tiene las columnas necesarias para Comparaciones (PRODUCT_TEST / RESPONSE).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "whiteness" && !tiposDisponibles.whiteness) {
        modeStatusEl.textContent =
          "‚ùå El archivo cargado no corresponde a un formato de Blancura (MONITOR, PRODUCT y m√©tricas WI).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "resumen" && !tiposDisponibles.resumen) {
        modeStatusEl.textContent =
          "‚ùå El archivo no parece tener estructura v√°lida para un resumen general.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "response_rel" && !tiposDisponibles.response_rel) {
        modeStatusEl.textContent =
          "‚ùå El archivo cargado no contiene la columna RESPONSE, necesaria para este an√°lisis.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      analysisMode = mode;
      currentPromptKey = promptKey || mode;

      questionEl.placeholder =
        "Prompt oficial cargado para el an√°lisis elegido. Puedes ajustarlo si lo deseas‚Ä¶";

      // === TEXTOS DE LOS PROMPTS INTERNOS (igual que ten√≠as) ===
      if (mode === "comparaciones") {
        if (currentPromptKey === "comparaciones_basico") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv para identificar cu√°l es el producto con mejor desempe√±o general. Para ello, toma en cuenta √∫nicamente las comparaciones en las que la columna RESPONSE tenga los valores 01.SUPERIOR o 02.SUPERIOR_TREND, que indican un resultado favorable para PRODUCT_TEST frente a PRODUCT_BENCH. Eval√∫a cu√°ntas veces cada valor de PRODUCT_TEST alcanza un resultado superior en todas las combinaciones posibles de las columnas MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. El producto que m√°s veces obtenga resultados favorables seg√∫n estos dos valores de RESPONSE debe ser considerado como el de mejor desempe√±o. La conclusi√≥n debe presentarse en texto continuo, indicando claramente cu√°l es el producto con mejor rendimiento y por qu√©, bas√°ndose en la frecuencia con la que obtiene un desempe√±o superior en las comparaciones.`;
        } else if (currentPromptKey === "comparaciones_escenarios") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv poniendo el foco en c√≥mo cambia el desempe√±o de los distintos PRODUCT_TEST seg√∫n las columnas MODALITY, SCENARIOS, WASH y PROCESS. Identifica para cada una de estas columnas qu√© productos tienden a concentrar m√°s respuestas 01.SUPERIOR y 02.SUPERIOR_TREND, se√±alando si hay formulaciones especialmente fuertes en determinados escenarios o modalidades y si existen contextos donde el rendimiento se reparte de forma m√°s equilibrada. La explicaci√≥n debe ser en texto continuo, resaltando las combinaciones producto‚Äìescenario m√°s robustas y aquellas donde las diferencias entre productos parecen menos marcadas.`;
        }
      } else if (mode === "whiteness") {
        if (currentPromptKey === "whiteness_basico") {
          questionEl.value =
`Para cada uno de los valores √∫nicos de la columna "MONITOR", identifica cu√°les son los productos ("PRODUCT") que presentan los valores m√°s altos en cada una de las m√©tricas de blancura: "1.2.WI_STw" (blancura est√°ndar), "2.2.WI_GEw" (blancura verdosa), "3.2.WI_VOw" (blancura viol√°cea) y "4.2.WI_LGw" (blancura luminosa). Para cada caso, indica en qu√© combinaciones espec√≠ficas de las variables "MODALITY", "SCENARIOS", "WASH" y "PROCESS" se presentan esos valores m√°ximos. Luego, compara entre los distintos productos dentro de cada tipo de monitor, resaltando si alg√∫n producto se destaca de forma consistente en m√°s de una m√©trica o en m√∫ltiples combinaciones. Finalmente, resume qu√© productos muestran un mejor desempe√±o global de blancura en funci√≥n del tipo de monitor utilizado, considerando la frecuencia con la que aparecen con los valores m√°s altos y la diversidad de condiciones en las que lo hacen.`;
        } else if (currentPromptKey === "whiteness_productos") {
          questionEl.value =
`Utiliza los datos de blancura del CSV para construir un perfil de cada "PRODUCT" en t√©rminos de las m√©tricas "1.2.WI_STw", "2.2.WI_GEw", "3.2.WI_VOw" y "4.2.WI_LGw" a trav√©s de todos los "MONITOR" disponibles. Describe en texto continuo qu√© productos se ubican con mayor frecuencia en los valores m√°ximos de blancura, cu√°les parecen m√°s equilibrados entre varias m√©tricas y cu√°les destacan solo en una dimensi√≥n espec√≠fica (por ejemplo, m√°s verdosa o m√°s luminosa). Indica tambi√©n si hay productos que cambian mucho su posici√≥n relativa seg√∫n el monitor utilizado, y qu√© implicaciones tiene esto para la lectura global de blancura.`;
        }
      } else if (mode === "resumen") {
        if (currentPromptKey === "resumen_basico") {
          questionEl.value =
`Haz un resumen general de la tabla del CSV, describiendo cu√°ntas filas y columnas contiene, qu√© tipo de informaci√≥n parece dominar (columnas num√©ricas frente a categ√≥ricas) y c√≥mo se distribuyen los valores. Menciona, de forma interpretativa, cu√°les son las columnas que parecen m√°s relevantes o m√°s variadas y qu√© patrones generales se pueden intuir solamente a partir de los recuentos y de los rangos de valores. La explicaci√≥n debe ir en texto continuo, sin listas, destacando las ideas principales sobre la estructura y el contenido de la tabla.`;
        } else if (currentPromptKey === "resumen_avanzado") {
          questionEl.value =
`Elabora un resumen avanzado de la tabla combinando la descripci√≥n estructural (n√∫mero de filas, columnas y tipos de variables) con una lectura m√°s interpretativa de qu√© grupos de columnas parecen estar relacionados entre s√≠. Sin realizar inferencias causales, comenta qu√© bloques de variables pueden agruparse (por ejemplo, columnas de contexto experimental frente a columnas de resultados) y c√≥mo podr√≠an utilizarse en an√°lisis posteriores m√°s espec√≠ficos. La explicaci√≥n debe ser narrativa, destacando las conexiones m√°s plausibles s√≥lo a partir de la estructura y de los recuentos.`;
        }
      } else if (mode === "response_rel") {
        if (currentPromptKey === "response_basico") {
          questionEl.value =
`Compara la distribuci√≥n de los valores de la columna RESPONSE con lo que ocurre en el resto de columnas del CSV. Identifica qu√© valores de RESPONSE son m√°s frecuentes y, para cada uno de ellos, describe qu√© patrones se observan en las columnas principales (productos, monitores, modalidades, escenarios, procesos, etc.). Explica de forma narrativa si hay combinaciones de valores que aparezcan m√°s asociadas a determinados resultados de RESPONSE, resaltando las tendencias m√°s claras que puedan deducirse √∫nicamente de los recuentos.`;
        } else if (currentPromptKey === "response_extremos") {
          questionEl.value =
`Profundiza en la columna RESPONSE distinguiendo claramente entre los resultados m√°s favorables y los menos favorables. Para cada grupo (por ejemplo, valores que representan superioridad, empate o inferioridad), describe qu√© patrones se observan en las columnas de producto, monitor, modalidad y escenario. Explica en texto continuo qu√© combinaciones parecen asociarse con respuestas especialmente buenas y cu√°les tienden a concentrar los peores resultados, utilizando √∫nicamente recuentos y frecuencias obtenidos del CSV.`;
        }
      }

      let modoTexto = "";
      if (mode === "comparaciones") modoTexto = "Comparaci√≥n PRODUCT_TEST vs RESPONSE (solo an√°lisis interno).";
      else if (mode === "whiteness") modoTexto = "Blancura por MONITOR (solo an√°lisis interno).";
      else if (mode === "resumen") modoTexto = "Resumen general / avanzado (an√°lisis interno).";
      else if (mode === "response_rel") modoTexto = "RESPONSE vs otras columnas (an√°lisis interno).";

      modeStatusEl.textContent = "‚úÖ Prompt interno seleccionado: " + modoTexto;

      if (llmStatusEl) {
        llmStatusEl.textContent =
          "‚ÑπÔ∏è Est√°s usando modo interno. El LLM s√≥lo se usa cuando activas Pregunta Abierta.";
      }
    }

    window.setMode = setModeInternal;

    // -------------------------------------------------------------
    // Pregunta Abierta: activa LLM con resumen num√©rico
    // -------------------------------------------------------------
    function activarPreguntaAbierta() {
      const llmStatusEl = document.getElementById("llmStatus");
      const questionEl  = document.getElementById("question");

      if (!csvFile) {
        modeStatusEl.textContent =
          "‚ö†Ô∏è Para usar Pregunta Abierta primero debes subir un CSV en la secci√≥n 1.";
        return;
      }

      // Marcar Pregunta Abierta y limpiar selecci√≥n de radio buttons
      openQuestionMode = true;
      analysisMode = "resumen";        // usaremos el an√°lisis de resumen para la secci√≥n 5
      currentPromptKey = "resumen_abierto";

      document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });

      questionEl.value = "";
      questionEl.placeholder =
        "Modo Pregunta Abierta: escribe aqu√≠ tu pregunta o enfoque. Se generar√° un resumen num√©rico en la secci√≥n 5 y la secci√≥n 6 vendr√° del LLM externo.";

      modeStatusEl.textContent =
        "üìù Pregunta Abierta activada: se usar√° un resumen general del CSV (secci√≥n 5) y el LLM responder√° en la secci√≥n 6.";

      if (llmStatusEl) {
        llmStatusEl.textContent =
          "‚úÖ Pregunta Abierta: el frontend calcular√° el resumen num√©rico y lo enviar√° junto con tu texto al backend /generate_answer.";
      }
    }

    window.activarPreguntaAbierta = activarPreguntaAbierta;

    // -------------------------------------------------------------
    // Llamada al backend FastAPI /generate_answer
    // -------------------------------------------------------------
    async function pedirExplicacionDesdeBackend(userPrompt, numericSummary, mode) {
      const textEl = document.getElementById("textOutput");
      const llmStatusEl = document.getElementById("llmStatus");

      if (!textEl) return;

      const pregunta = (userPrompt || "").trim();
      const resumen  = (numericSummary || "").trim();

      textEl.textContent = "‚è≥ Llamando al backend /generate_answer‚Ä¶";

      try {
        const resp = await fetch(BACKEND_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            mode: mode || "general",
            question: pregunta,
            numeric_summary: resumen
          })
        });

        if (!resp.ok) {
          const msg = "Respuesta HTTP no OK: " + resp.status;
          console.error(msg);
          textEl.textContent =
            "‚ùå Error llamando al backend.\n" +
            msg +
            "\n\nPuedes revisar el resumen num√©rico en la secci√≥n 5 y, si lo deseas, copiarlo en tu propio an√°lisis.";
          if (llmStatusEl) {
            llmStatusEl.textContent = "‚ùå Backend /generate_answer respondi√≥ con error " + resp.status + ".";
          }
          return;
        }

        const data = await resp.json();
        const answer = (data && data.answer) ? String(data.answer).trim() : "";

        if (!answer) {
          textEl.textContent =
            "‚ö†Ô∏è El backend no devolvi√≥ una respuesta de texto utilizable.\n" +
            "Revisa el resumen num√©rico en la secci√≥n 5 para interpretar manualmente.";
          if (llmStatusEl) {
            llmStatusEl.textContent = "‚ö†Ô∏è Backend sin respuesta de texto.";
          }
        } else {
          textEl.textContent = answer;
          if (llmStatusEl) {
            llmStatusEl.textContent = "‚úÖ Respuesta generada por el backend /generate_answer (Pregunta Abierta).";
          }
        }
      } catch (err) {
        console.error("Error llamando al backend:", err);
        textEl.textContent =
          "‚ùå Error de red al llamar al backend /generate_answer.\n" +
          "Revisa tu conexi√≥n o el estado del Space en Hugging Face.";
        if (llmStatusEl) {
          llmStatusEl.textContent = "‚ùå Error de red hacia el backend.";
        }
      }
    }

    // -------------------------------------------------------------
    // Bot√≥n principal: analizar CSV
    // -------------------------------------------------------------
    function analizarCSVInternal() {
      const statusEl = document.getElementById("analysisStatus");
      const numericEl = document.getElementById("numericOutput");
      const textEl = document.getElementById("textOutput");
      const question = document.getElementById("question").value.trim();

      if (!csvFile) {
        statusEl.textContent = "‚ö†Ô∏è Sube primero el archivo CSV en la secci√≥n 1.";
        return;
      }

      // Si estamos en Pregunta Abierta forzamos modo resumen+LLM
      if (openQuestionMode) {
        analysisMode = "resumen";
        if (!question) {
          statusEl.textContent = "‚ö†Ô∏è En Pregunta Abierta debes escribir una pregunta o enfoque en la secci√≥n 3.";
          return;
        }
      } else if (!analysisMode) {
        statusEl.textContent = "‚ö†Ô∏è Elige un tipo de an√°lisis en la secci√≥n 2 o usa Pregunta Abierta.";
        return;
      }

      let modoTxt = "";
      if (openQuestionMode) modoTxt = "RESUMEN + LLM (Pregunta Abierta)";
      else if (analysisMode === "whiteness") modoTxt = "BLANCURA (interno)";
      else if (analysisMode === "comparaciones") modoTxt = "COMPARACIONES (interno)";
      else if (analysisMode === "resumen") modoTxt = "RESUMEN (interno, sin LLM)";
      else if (analysisMode === "response_rel") modoTxt = "RESPONSE vs OTRAS COLUMNAS (interno)";

      statusEl.textContent = "‚è≥ Analizando CSV en modo: " + modoTxt + "‚Ä¶";

      numericEl.textContent = "// Procesando CSV, esto puede tardar para archivos grandes‚Ä¶";
      textEl.textContent = "// Preparando explicaci√≥n‚Ä¶";

      if (analysisMode === "whiteness") {
        analizarBlancura(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "comparaciones") {
        analizarComparaciones(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "resumen") {
        // usarBackendLLM = true solo si Pregunta Abierta est√° activa
        const usarBackendLLM = openQuestionMode;
        analizarResumen(statusEl, numericEl, textEl, question, usarBackendLLM);
      } else if (analysisMode === "response_rel") {
        analizarResponseVsOtros(statusEl, numericEl, textEl, question);
      }
    }

    window.analizarCSV = analizarCSVInternal;

    // -------------------------------------------------------------
    // Modo 1: Comparaciones PRODUCT_TEST vs RESPONSE (interno)
    // -------------------------------------------------------------
    function analizarComparaciones(statusEl, numericEl, textEl, userPrompt) {
      const objetivos = new Set(["01.SUPERIOR", "02.SUPERIOR_TREND"]);
      const conteos = {};
      let totalFilas = 0;
      let totalFiltradas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const resp = (row["RESPONSE"] || "").trim();
            if (objetivos.has(resp)) {
              totalFiltradas++;
              const ptest = (row["PRODUCT_TEST"] || "").trim() || "(VAC√çO)";
              conteos[ptest] = (conteos[ptest] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (Object.keys(conteos).length === 0) {
            statusEl.textContent = "‚ùå No se encontraron filas con RESPONSE = 01.SUPERIOR o 02.SUPERIOR_TREND.";
            numericEl.textContent = "// Sin resultados favorables para PRODUCT_TEST.";
            textEl.textContent = "// No hay suficientes datos favorables para generar una conclusi√≥n.";
            return;
          }

          const ordenados = Object.entries(conteos).sort((a,b) => b[1] - a[1]);
          const totalFavorables = ordenados.reduce((s, [,c]) => s + c, 0);

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n";
          numTxt += "Filas con RESPONSE en {01.SUPERIOR, 02.SUPERIOR_TREND}: " + totalFiltradas + "\n\n";
          numTxt += "Conteo de resultados favorables por PRODUCT_TEST:\n";
          for (const [prod, cnt] of ordenados) {
            const pct = totalFavorables > 0 ? (cnt * 100 / totalFavorables).toFixed(2) + "%" : "‚Äì";
            numTxt += "  - " + prod + ": " + cnt + " (" + pct + " de los favorables)\n";
          }
          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaComparaciones(
            userPrompt,
            ordenados,
            totalFilas,
            totalFiltradas,
            totalFavorables
          );

          statusEl.textContent = "‚úÖ An√°lisis de comparaciones completado (interno).";
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    // üëâ CAMBIO: ya NO se repite el prompt, intro gen√©rica
    function construirExplicacionLargaComparaciones(
      userPrompt,
      ordenados,
      totalFilas,
      totalFiltradas,
      totalFavorables
    ) {
      const [prodGanador, cntGanador] = ordenados[0];
      const pctGanador = totalFavorables > 0 ? (cntGanador * 100 / totalFavorables).toFixed(1) : null;

      const promptIntro =
        "En este an√°lisis se ha considerado la informaci√≥n contenida en el archivo de comparaciones, " +
        "enfoc√°ndose en las filas donde la respuesta indica un desempe√±o superior para PRODUCT_TEST frente a PRODUCT_BENCH.\n\n";

      const otros = ordenados.slice(1, Math.min(6, ordenados.length));
      let texto = "";

      texto += promptIntro;
      texto += "El archivo incluye un total de " + totalFilas + " filas, pero para evaluar el desempe√±o real de los productos se filtraron √∫nicamente aquellos casos en los que la columna RESPONSE toma los valores 01.SUPERIOR o 02.SUPERIOR_TREND. ";
      texto += "Tras este filtrado, quedaron " + totalFiltradas + " observaciones que pueden considerarse evidencias de superioridad o tendencia a la superioridad. ";
      texto += "A partir de este conjunto depurado se contabiliz√≥ cu√°ntas veces cada valor de PRODUCT_TEST aparece asociado a un resultado favorable, agrupando todos los escenarios de MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD para tener una visi√≥n global.\n\n";

      texto += "Los resultados muestran que el producto que m√°s veces alcanza un resultado favorable es ¬´" + prodGanador + "¬ª, con " + cntGanador + " ocurrencias. ";
      if (pctGanador !== null) {
        texto += "Si se compara este n√∫mero con el total de casos favorables, ¬´" + prodGanador + "¬ª concentra aproximadamente el " + pctGanador + "% de todas las situaciones en las que alg√∫n producto gana frente al benchmark. ";
      }
      texto += "Este nivel de presencia indica que ¬´" + prodGanador + "¬ª tiende a repetir este comportamiento a lo largo de diversas combinaciones de condiciones de lavado, tipo de tejido, escenario de suciedad, monitor de evaluaci√≥n y umbral de decisi√≥n.\n\n";

      if (otros.length > 0) {
        texto += "Cuando se observa el resto de productos, aparecen otras formulaciones que logran tambi√©n un n√∫mero significativo de victorias, aunque siempre por debajo de ¬´" + prodGanador + "¬ª. ";
        texto += "Entre los principales competidores se encuentran:\n\n";

        otros.forEach(([prod, cnt]) => {
          const pct = totalFavorables > 0 ? (cnt * 100 / totalFavorables).toFixed(1) : null;
          texto += "‚Ä¢ ¬´" + prod + "¬ª con " + cnt + " resultados favorables";
          if (pct !== null) {
            texto += ", lo que representa aproximadamente el " + pct + "% del total de casos favorables";
          }
          texto += ".\n";
        });
        texto += "\n";
      }

      texto += "M√°s all√° del simple conteo de victorias, es importante considerar la diversidad de contextos en los que se produce la superioridad. ";
      texto += "Cada fila corresponde a una combinaci√≥n espec√≠fica de MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. ";
      texto += "Que un producto aparezca repetidamente como superior sugiere que su formulaci√≥n es robusta frente a cambios en estas variables.\n\n";

      texto += "En resumen, considerando exclusivamente las filas en las que PRODUCT_TEST demuestra superioridad frente a PRODUCT_BENCH, ";
      texto += "el an√°lisis pone de manifiesto que ¬´" + prodGanador + "¬ª es el producto con mejor desempe√±o global en t√©rminos de frecuencia de victorias y potencial robustez a trav√©s de distintos escenarios.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 2: Blancura por MONITOR (interno)
    // -------------------------------------------------------------
    function analizarBlancura(statusEl, numericEl, textEl, userPrompt) {
      const data = {};
      let totalFilas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const monitor = (row["MONITOR"] || "").trim();
            const product = (row["PRODUCT"] || "").trim();
            if (!monitor || !product) continue;

            for (const m of whitenessMetrics) {
              if (!(m in row)) continue;
              const v = parseFloat(row[m]);
              if (Number.isNaN(v)) continue;

              if (!data[monitor]) data[monitor] = {};
              if (!data[monitor][m]) data[monitor][m] = { max: null, rows: [] };

              const entry = data[monitor][m];
              if (entry.max === null || v > entry.max) {
                entry.max = v;
                entry.rows = [{
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                }];
              } else if (v === entry.max) {
                entry.rows.push({
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                });
              }
            }
          }
        },
        complete: function() {
          if (!Object.keys(data).length) {
            statusEl.textContent = "‚ùå No se encontraron datos v√°lidos de blancura por MONITOR.";
            numericEl.textContent = "// Sin resultados de m√©tricas de blancura.";
            textEl.textContent = "// No hay suficientes datos de blancura para generar una conclusi√≥n.";
            return;
          }

          const globalCounts = {};
          for (const monitor of Object.keys(data)) {
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              for (const row of info.rows) {
                const prod = row.PRODUCT || "(VAC√çO)";
                globalCounts[prod] = (globalCounts[prod] || 0) + 1;
              }
            }
          }

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n\n";
          numTxt += "M√°ximos de blancura por MONITOR y m√©trica:\n";
          for (const monitor of Object.keys(data).sort()) {
            numTxt += "MONITOR = " + monitor + "\n";
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              numTxt += "  M√©trica: " + metric + ", valor m√°ximo: " + info.max + "\n";
              for (const row of info.rows) {
                numTxt += "    - PRODUCT = " + row.PRODUCT +
                          ", MODALITY = " + row.MODALITY +
                          ", SCENARIOS = " + row.SCENARIOS +
                          ", WASH = " + row.WASH +
                          ", PROCESS = " + row.PROCESS + "\n";
              }
            }
            numTxt += "\n";
          }

          numTxt += "Conteo global de apariciones como m√°ximo de blancura por PRODUCT:\n";
          const globalSorted = Object.entries(globalCounts).sort((a,b) => b[1] - a[1]);
          for (const [prod, cnt] of globalSorted) {
            numTxt += "  - " + prod + ": " + cnt + "\n";
          }

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaBlancura(userPrompt, data, globalSorted);

          statusEl.textContent = "‚úÖ An√°lisis de blancura completado (interno).";
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    // üëâ CAMBIO: intro gen√©rica, sin repetir prompt
    function construirExplicacionLargaBlancura(userPrompt, data, globalSorted) {
      if (!globalSorted.length) {
        return "// No se pudieron construir patrones globales de blancura.";
      }
      const [prodTop, cntTop] = globalSorted[0];

      const promptIntro =
        "En este an√°lisis se ha estudiado el comportamiento de la blancura a partir de los datos del CSV.\n\n";

      let texto = "";
      texto += promptIntro;
      texto += "A partir de las m√©tricas de blancura asociadas a cada MONITOR, se identificaron los valores m√°ximos de las distintas m√©tricas WI en funci√≥n de las combinaciones de producto, modalidad de lavado, escenario de suciedad y proceso. ";
      texto += "El recuento global de apariciones como m√°ximo de blancura muestra que el producto que m√°s veces lidera es ¬´" + prodTop + "¬ª, con " + cntTop + " apariciones entre todas las combinaciones de MONITOR y m√©tricas de blancura consideradas.\n\n";

      texto += "Este patr√≥n sugiere que la formulaci√≥n asociada a ¬´" + prodTop + "¬ª tiene una capacidad notable para generar niveles elevados de blancura en condiciones variadas. ";
      texto += "Aunque otros productos tambi√©n alcanzan en ocasiones los valores m√°ximos en determinados monitores o m√©tricas, la frecuencia con la que ¬´" + prodTop + "¬ª aparece como referencia indica una ventaja global en t√©rminos de consistencia.\n\n";

      texto += "Al desglosar los resultados por monitor, se observa que cada sistema de evaluaci√≥n aporta matices distintos: algunos monitores pueden ser m√°s sensibles a diferencias de matiz verdoso o viol√°ceo, mientras que otros ponen m√°s √©nfasis en la blancura luminosa o est√°ndar. ";
      texto += "El hecho de que un mismo producto destaque repetidamente en diferentes monitores y m√©tricas refuerza la idea de una blancura percibida m√°s s√≥lida en un rango amplio de condiciones.\n\n";

      texto += "En conjunto, y siempre dentro de los l√≠mites del CSV analizado, los datos apuntan a que ¬´" + prodTop + "¬ª ofrece un mejor desempe√±o global cuando se consideran simult√°neamente los distintos monitores y las m√©tricas de blancura estudiadas. ";
      texto += "Otros productos pueden mostrar picos de rendimiento en contextos concretos, pero ninguno parece igualar la combinaci√≥n de frecuencia y diversidad de situaciones en las que ¬´" + prodTop + "¬ª se sit√∫a en la parte alta del ranking de blancura.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 3: Resumen general de la tabla
    //   - Interno normal
    //   - O con LLM cuando openQuestionMode = true (usarBackendLLM = true)
    // -------------------------------------------------------------
    function analizarResumen(statusEl, numericEl, textEl, userPrompt, usarBackendLLM) {
      const stats = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            for (const col of Object.keys(row)) {
              if (!stats[col]) {
                stats[col] = {
                  numericCount: 0,
                  nonNumericCount: 0,
                  sum: 0,
                  min: null,
                  max: null,
                  categories: {}
                };
              }
              const valRaw = row[col];
              if (valRaw === null || valRaw === undefined) continue;
              const val = String(valRaw).trim();
              if (val === "") continue;

              const num = parseFloat(val.replace(",", "."));
              if (!Number.isNaN(num) && val.match(/^[+-]?(\d+(\.\d+)?|\.\d+)$/)) {
                stats[col].numericCount++;
                stats[col].sum += num;
                if (stats[col].min === null || num < stats[col].min) stats[col].min = num;
                if (stats[col].max === null || num > stats[col].max) stats[col].max = num;
              } else {
                stats[col].nonNumericCount++;
                stats[col].categories[val] = (stats[col].categories[val] || 0) + 1;
              }
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "‚ùå No se pudo detectar estructura v√°lida en el CSV.";
            numericEl.textContent = "// Sin informaci√≥n estructural disponible.";
            textEl.textContent = "// No hay suficiente informaci√≥n para generar un resumen.";
            return;
          }

          const numCols = headersLocal.length;
          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n";
          numTxt += "Total de columnas detectadas: " + numCols + "\n\n";

          numTxt += "Resumen por columna:\n";
          headersLocal.forEach(col => {
            const s = stats[col] || {
              numericCount: 0, nonNumericCount: 0,
              sum: 0, min: null, max: null, categories: {}
            };
            const esNumerica = s.numericCount > 0 && s.nonNumericCount === 0;
            numTxt += "Columna: " + col + "\n";
            if (esNumerica) {
              const mean = s.numericCount > 0 ? (s.sum / s.numericCount) : null;
              numTxt += "  Tipo: num√©rica\n";
              numTxt += "  Valores v√°lidos: " + s.numericCount + "\n";
              if (s.min !== null && s.max !== null) {
                numTxt += "  Rango aproximado: [" + s.min + ", " + s.max + "]\n";
              }
              if (mean !== null) {
                numTxt += "  Promedio aproximado: " + mean + "\n";
              }
            } else {
              const cats = Object.entries(s.categories);
              numTxt += "  Tipo: categ√≥rica / mixta\n";
              numTxt += "  Valores no vac√≠os: " + (s.numericCount + s.nonNumericCount) + "\n";
              numTxt += "  N¬∫ de categor√≠as distintas: " + cats.length + "\n";
              if (cats.length) {
                const topCats = cats.sort((a,b) => b[1]-a[1]).slice(0,5);
                numTxt += "  Categor√≠as m√°s frecuentes:\n";
                topCats.forEach(([v,c]) => {
                  numTxt += "    - " + v + " (" + c + " ocurrencias)\n";
                });
              }
            }
            numTxt += "\n";
          });

          numericEl.textContent = numTxt;

          if (usarBackendLLM) {
            // Pregunta Abierta: usamos el backend LLM con el resumen num√©rico
            pedirExplicacionDesdeBackend(userPrompt, numTxt, "resumen");
            statusEl.textContent = "‚úÖ Resumen num√©rico generado. Esperando respuesta del LLM en la secci√≥n 6‚Ä¶";
          } else {
            // Modo interno normal
            textEl.textContent = construirExplicacionLargaResumen(
              userPrompt,
              totalFilas,
              headersLocal,
              stats
            );
            statusEl.textContent = "‚úÖ Resumen general / avanzado completado (interno).";
          }
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    // üëâ CAMBIO: intro gen√©rica, sin citar el prompt
    function construirExplicacionLargaResumen(userPrompt, totalFilas, headersLocal, stats) {
      const promptIntro =
        "A continuaci√≥n se presenta un resumen general de la estructura y el contenido del CSV analizado.\n\n";

      let texto = "";
      texto += promptIntro;
      texto += "La tabla analizada contiene un total de " + totalFilas + " filas y " +
               headersLocal.length + " columnas, lo que ya sugiere un volumen de informaci√≥n suficiente como para identificar patrones y variaciones entre distintos campos.\n\n";

      const colsNumericas = [];
      const colsCateg = [];
      headersLocal.forEach(col => {
        const s = stats[col];
        if (!s) return;
        const esNumerica = s.numericCount > 0 && s.nonNumericCount === 0;
        if (esNumerica) colsNumericas.push(col);
        else colsCateg.push(col);
      });

      if (colsNumericas.length > 0) {
        texto += "En cuanto a variables num√©ricas, se identifican columnas como ";
        texto += "¬´" + colsNumericas.slice(0,4).join("¬ª, ¬´") + "¬ª";
        if (colsNumericas.length > 4) {
          texto += " y otras m√°s, que completan un conjunto de " + colsNumericas.length + " columnas de car√°cter cuantitativo. ";
        } else {
          texto += ", que en conjunto conforman el n√∫cleo de informaci√≥n num√©rica de la tabla. ";
        }
        texto += "Estas columnas permiten estimar rangos, promedios y posibles diferencias entre productos, escenarios o procesos, seg√∫n la naturaleza espec√≠fica de cada campo.\n\n";
      }

      if (colsCateg.length > 0) {
        texto += "Por el lado de las variables categ√≥ricas o mixtas, aparecen columnas como ";
        texto += "¬´" + colsCateg.slice(0,4).join("¬ª, ¬´") + "¬ª";
        if (colsCateg.length > 4) {
          texto += " y varias m√°s, que aportan etiquetas y clasificaciones clave para interpretar los resultados num√©ricos. ";
        } else {
          texto += ", que sirven como ejes de segmentaci√≥n para organizar la informaci√≥n de la tabla. ";
        }
        texto += "En estas columnas suelen concentrarse c√≥digos de producto, tipos de monitor, modalidades de lavado, escenarios de suciedad o procesos, lo que permite dividir la informaci√≥n en grupos comparables.\n\n";
      }

      texto += "Si se observa el comportamiento interno de cada columna, se aprecia que algunas presentan una gran diversidad de categor√≠as, mientras que otras se concentran en unos pocos valores recurrentes. ";
      texto += "Las columnas con muchas categor√≠as distintas pueden estar capturando una variedad amplia de situaciones o combinaciones experimentales, mientras que aquellas con pocos valores dominantes indican focos claros de inter√©s o configuraciones repetidas a lo largo del experimento.\n\n";

      texto += "En t√©rminos generales, la estructura de la tabla ofrece un equilibrio entre campos num√©ricos y categ√≥ricos, lo que facilita la construcci√≥n de indicadores agregados (promedios, m√°ximos, rangos) y, al mismo tiempo, la segmentaci√≥n por tipo de producto, monitor o escenario. ";
      texto += "Este equilibrio es especialmente √∫til en contextos de evaluaci√≥n comparativa, donde no solo importa el valor num√©rico aislado, sino tambi√©n el contexto experimental en el que se obtiene.\n\n";

      texto += "De este modo, el CSV no solo act√∫a como un contenedor de resultados, sino como un mapa donde cada columna a√±ade una capa distinta de significado: unas cuantifican el desempe√±o, otras describen las condiciones de prueba y otras organizan las observaciones en familias coherentes. ";
      texto += "La combinaci√≥n de todas ellas permite construir lecturas m√°s ricas sobre el comportamiento de los productos y sobre c√≥mo cambian los resultados al modificar los distintos factores del experimento.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 4: Comparar RESPONSE con las dem√°s columnas (interno)
    // -------------------------------------------------------------
    function analizarResponseVsOtros(statusEl, numericEl, textEl, userPrompt) {
      const responseCounts = {};
      const responseColumnCounts = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            const rRaw = row["RESPONSE"];
            const resp = (rRaw === undefined || rRaw === null || String(rRaw).trim() === "")
              ? "(VAC√çO)" : String(rRaw).trim();
            responseCounts[resp] = (responseCounts[resp] || 0) + 1;

            for (const col of headersLocal) {
              if (col === "RESPONSE") continue;
              const vRaw = row[col];
              const val = (vRaw === undefined || vRaw === null || String(vRaw).trim() === "")
                ? "(VAC√çO)" : String(vRaw).trim();

              if (!responseColumnCounts[col]) responseColumnCounts[col] = {};
              if (!responseColumnCounts[col][resp]) responseColumnCounts[col][resp] = {};
              responseColumnCounts[col][resp][val] =
                (responseColumnCounts[col][resp][val] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "‚ùå No se pudo detectar estructura v√°lida en el CSV.";
            numericEl.textContent = "// Sin informaci√≥n estructural disponible.";
            textEl.textContent = "// No hay suficiente informaci√≥n para analizar RESPONSE.";
            return;
          }

          const sortedResponses = Object.entries(responseCounts).sort((a,b) => b[1]-a[1]);

          let numTxt = "";
          numTxt += "Total de filas le√≠das: " + totalFilas + "\n\n";
          numTxt += "Distribuci√≥n de la columna RESPONSE:\n";
          sortedResponses.forEach(([r,c]) => {
            const pct = totalFilas > 0 ? (c*100/totalFilas).toFixed(2) + "%" : "‚Äì";
            numTxt += "  - " + r + ": " + c + " filas (" + pct + ")\n";
          });
          numTxt += "\n";

          numTxt += "Asociaciones entre RESPONSE y el resto de columnas (primeras 6 columnas distintas de RESPONSE):\n";
          const colsAnalizar = headersLocal.filter(c => c !== "RESPONSE").slice(0,6);

          const resumenColumnas = [];

          colsAnalizar.forEach(col => {
            const byResp = responseColumnCounts[col] || {};
            numTxt += "\nColumna: " + col + "\n";
            const perResponseTop = {};
            sortedResponses.forEach(([resp, _cntR]) => {
              const mapaValores = byResp[resp];
              if (!mapaValores) return;
              const sortedVals = Object.entries(mapaValores).sort((a,b) => b[1]-a[1]).slice(0,3);
              if (!sortedVals.length) return;
              perResponseTop[resp] = sortedVals;

              numTxt += "  RESPONSE = " + resp + ":\n";
              sortedVals.forEach(([v,c]) => {
                numTxt += "    - " + v + " (" + c + " filas)\n";
              });
            });
            resumenColumnas.push({ columna: col, perResponseTop });
          });

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaResponseRel(
            userPrompt,
            totalFilas,
            sortedResponses,
            resumenColumnas
          );

          statusEl.textContent = "‚úÖ An√°lisis RESPONSE vs otras columnas completado (interno).";
        },
        error: function(err) {
          statusEl.textContent = "‚ùå Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    // üëâ CAMBIO: intro gen√©rica, sin repetir el texto del prompt
    function construirExplicacionLargaResponseRel(
      userPrompt,
      totalFilas,
      sortedResponses,
      resumenColumnas
    ) {
      const promptIntro =
        "En este apartado se explora c√≥mo se distribuye RESPONSE y qu√© asociaciones se observan con las dem√°s columnas del CSV.\n\n";

      let texto = "";
      texto += promptIntro;

      if (!sortedResponses.length) {
        texto += "En la pr√°ctica, no se han encontrado valores informativos en la columna RESPONSE, por lo que no es posible establecer patrones claros frente al resto de columnas.\n";
        return texto;
      }

      const [respTop, cntTop] = sortedResponses[0];
      const pctTop = totalFilas > 0 ? (cntTop*100/totalFilas).toFixed(1) : null;

      texto += "Al observar la distribuci√≥n general, la columna RESPONSE se reparte en varios valores posibles, pero el que domina con mayor peso es ¬´" + respTop + "¬ª, que re√∫ne " + cntTop + " filas";
      if (pctTop !== null) {
        texto += ", lo que equivale aproximadamente al " + pctTop + "% del total de registros";
      }
      texto += ". El resto de valores de RESPONSE aparece con menor frecuencia, conformando una cola de resultados menos habituales que tambi√©n contribuyen a matizar la lectura global.\n\n";

      if (sortedResponses.length > 1) {
        const segundas = sortedResponses.slice(1,3);
        if (segundas.length) {
          texto += "Adem√°s de este valor dominante, se identifican otros resultados de RESPONSE que, aunque menos frecuentes, re√∫nen un n√∫mero apreciable de casos. ";
          texto += "Entre ellos destacan ";
          texto += segundas.map(([r,c]) => "¬´" + r + "¬ª (" + c + " filas)").join(" y ");
          texto += ", que completan el mapa de respuestas posibles en el experimento.\n\n";
        }
      }

      if (!resumenColumnas.length) {
        texto += "Al relacionar RESPONSE con el resto de columnas, no se han encontrado patrones suficientemente claros como para destacar asociaciones espec√≠ficas, posiblemente debido a la dispersi√≥n de los datos o a la diversidad de valores. ";
        texto += "Aun as√≠, la distribuci√≥n global de RESPONSE ya permite intuir qu√© resultados se repiten con mayor insistencia en el conjunto de ensayos.\n";
        return texto;
      }

      texto += "Cuando se cruza RESPONSE con otras columnas clave de la tabla, comienzan a aparecer patrones m√°s concretos. ";
      texto += "Cada columna act√∫a como un eje de segmentaci√≥n que permite ver qu√© combinaciones de valores se repiten con mayor frecuencia para cada tipo de respuesta.\n\n";

      const columnasComentadas = resumenColumnas.slice(0,3);
      columnasComentadas.forEach(colInfo => {
        const colName = colInfo.columna;
        const perResponseTop = colInfo.perResponseTop || {};
        texto += "En la columna ¬´" + colName + "¬ª, las distribuciones por RESPONSE muestran que:\n";

        const respuestasComentadas = Object.entries(perResponseTop).slice(0,2);
        if (!respuestasComentadas.length) {
          texto += "  No se observan concentraciones claras asociadas a valores espec√≠ficos de RESPONSE en esta columna.\n\n";
          return;
        }

        respuestasComentadas.forEach(([respVal, topVals]) => {
          if (!topVals || !topVals.length) return;
          const lista = topVals.map(([v,c]) => "¬´" + v + "¬ª (" + c + " filas)").join(", ");
          texto += "  Para RESPONSE = ¬´" + respVal + "¬ª predominan valores como " + lista + ".\n";
        });
        texto += "\n";
      });

      texto += "En conjunto, estas asociaciones no deben interpretarse como relaciones causales directas, pero s√≠ como indicios de que ciertos contextos (definidos por productos, monitores, modalidades o escenarios) tienden a coincidir con determinados resultados de RESPONSE con mayor frecuencia que otros. ";
      texto += "Esto convierte a RESPONSE en una especie de indicador de salida que resume el efecto combinado de todas esas columnas, y a los patrones detectados en un punto de partida √∫til para explorar con m√°s detalle qu√© configuraciones experimentales est√°n detr√°s de los mejores y peores desempe√±os.\n";

      return texto;
    }
  </script>
</body>
</html>
