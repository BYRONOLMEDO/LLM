<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>CHATBOT para uso de los CSV de Consumertec</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- PapaParse para procesar CSV en el navegador -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root{
      --bg:#020617;
      --card:#020617;
      --border:#1f2937;
      --accent:#22d3ee;
      --accent2:#4ade80;
      --text:#e5e7eb;
      --muted:#9ca3af;
    }
    *{box-sizing:border-box;margin:0;padding:0;}
    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#0f172a,#020617);
      color:var(--text);
      padding:10px;
    }
    .card{
      width:min(1100px,100%);
      max-height:96vh;
      background:var(--card);
      border-radius:20px;
      border:1px solid var(--border);
      padding:18px 20px;
      box-shadow:0 22px 50px rgba(0,0,0,0.6);
      display:flex;
      flex-direction:column;
      gap:12px;
      overflow-y:auto;
    }
    h1{
      font-size:1.7rem;
      text-align:center;
      margin-bottom:4px;
    }
    p{
      font-size:0.9rem;
      line-height:1.5;
      color:var(--muted);
      text-align:justify;
      text-justify:inter-word;
    }
    .section-title{
      font-size:1rem;
      font-weight:600;
      margin-bottom:4px;
      margin-top:8px;
    }
    label{
      font-size:0.85rem;
      margin-bottom:4px;
      display:block;
      color:var(--muted);
    }
    input[type="file"]{
      width:100%;
      padding:8px;
      border-radius:10px;
      border:1px dashed var(--border);
      background:#020617;
      color:var(--muted);
      font-size:0.85rem;
    }
    textarea{
      width:100%;
      min-height:90px;
      max-height:200px;
      resize:vertical;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      color:var(--text);
      padding:8px 10px;
      font-size:0.85rem;
      line-height:1.4;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:6px;
      align-items:center;
    }
    .row > *{
      flex:1 1 auto;
    }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:8px 16px;
      border-radius:999px;
      text-decoration:none;
      border:none;
      background:linear-gradient(135deg,var(--accent),var(--accent2));
      color:#020617;
      font-weight:600;
      font-size:0.85rem;
      letter-spacing:0.02em;
      cursor:pointer;
      transition:transform 0.1s ease, filter 0.1s ease;
      white-space:nowrap;
    }
    .btn.secondary{
      background:#111827;
      color:var(--muted);
      border:1px solid var(--border);
    }
    .btn:hover{
      filter:brightness(1.06);
      transform:translateY(-1px);
    }
    .status{
      font-size:0.83rem;
      color:var(--muted);
      margin-top:4px;
    }
    .output-box{
      margin-top:8px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#020617;
      padding:8px 10px;
      font-size:0.83rem;
      line-height:1.45;
      max-height:260px;
      overflow:auto;
      white-space:pre-wrap;
    }
    .small{
      font-size:0.8rem;
      color:var(--muted);
    }
    .mode-options{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:4px;
      flex-wrap:wrap;
    }
    .mode-group{
      display:flex;
      flex-wrap:wrap;
      gap:12px;
    }
    .mode-group.hidden{
      display:none;
    }
    .mode-group.disabled{
      opacity:0.3;
      pointer-events:none;
    }
    .mode-options label{
      display:flex;
      align-items:center;
      gap:6px;
      cursor:pointer;
      font-size:0.85rem;
    }
    .mode-options input[type="radio"]{
      accent-color:#22d3ee;
      width:16px;
      height:16px;
    }
    /* Sección 6: más alta y scrollbar garantizado para textos largos */
    #textOutput{
      max-height:60vh;
      overflow-y:auto;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>CHATBOT para uso de los CSV de Consumertec</h1>
    <p>
      Este chatbot está diseñado para trabajar con archivos <strong>OUTPUT_MAP_COMPARISONS.csv</strong> y
      otros CSV derivados de los experimentos de Consumertec. Primero se <strong>sube en la sección 1</strong>
      el archivo CSV que se desea analizar. A partir de su estructura, en la <strong>sección 2</strong> se
      activan los <strong>prompts internos</strong> compatibles (comparaciones, blancura, resumen general,
      relación de RESPONSE con las demás columnas o sus variantes avanzadas). Después se ejecuta el análisis:
      el sistema genera un resumen numérico y una explicación en texto continuo basada únicamente en los datos
      del archivo.
    </p>

    <!-- Estado del motor (solo cálculo interno, sin LLM externo) -->
    <div id="llmStatus" class="status small">
      ℹ️ Este chatbot utiliza únicamente cálculos internos sobre tu CSV; no se conecta a ningún modelo externo.
    </div>

    <!-- Subir CSV (ahora SECCIÓN 1) -->
    <div>
      <div class="section-title">1. Subir archivo CSV</div>
      <label for="csvInput" id="csvLabel">
        Sube primero el CSV que quieres analizar. Según sus columnas, se activarán las opciones de análisis en la sección 2.
      </label>
      <input id="csvInput" type="file" accept=".csv" />
      <div id="fileStatus" class="status">⚠️ Ningún archivo seleccionado.</div>
    </div>

    <!-- Elegir tipo de análisis + prompt interno (ahora SECCIÓN 2) -->
    <div>
      <div class="section-title">2. Elegir tipo de análisis y prompt interno</div>
      <p class="small">
        Después de subir el CSV, se mostrarán aquí los tipos de análisis compatibles. Cada tipo activa sus
        prompts internos. Al elegir uno, se cargará automáticamente un texto recomendado en la sección 3,
        que puedes editar libremente.
      </p>

      <div class="mode-options">
        <!-- Grupo Comparaciones -->
        <div id="group_comparaciones" class="mode-group hidden">
          <label>
            <input id="mode_comparaciones_basico" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_basico')" />
            Prompt 1 — Comparación (PRODUCT_TEST vs RESPONSE)
          </label>
          <label>
            <input id="mode_comparaciones_escenarios" type="radio" name="mode"
                   onclick="setMode('comparaciones','comparaciones_escenarios')" />
            Prompt 5 — Comparación por escenarios y modalidades
          </label>
        </div>

        <!-- Grupo Blancura -->
        <div id="group_whiteness" class="mode-group hidden">
          <label>
            <input id="mode_whiteness_basico" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_basico')" />
            Prompt 2 — Blancura por MONITOR (métricas WI)
          </label>
          <label>
            <input id="mode_whiteness_productos" type="radio" name="mode"
                   onclick="setMode('whiteness','whiteness_productos')" />
            Prompt 6 — Perfil de blancura por producto
          </label>
        </div>

        <!-- Grupo Resumen -->
        <div id="group_resumen" class="mode-group hidden">
          <label>
            <input id="mode_resumen_basico" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_basico')" />
            Prompt 3 — Resumen general de la tabla
          </label>
          <label>
            <input id="mode_resumen_avanzado" type="radio" name="mode"
                   onclick="setMode('resumen','resumen_avanzado')" />
            Prompt 7 — Resumen avanzado y bloques de variables
          </label>
        </div>

        <!-- Grupo RESPONSE vs otras columnas -->
        <div id="group_response_rel" class="mode-group hidden">
          <label>
            <input id="mode_response_basico" type="radio" name="mode"
                   onclick="setMode('response_rel','response_basico')" />
            Prompt 4 — Comparar RESPONSE con las demás columnas
          </label>
          <label>
            <input id="mode_response_extremos" type="radio" name="mode"
                   onclick="setMode('response_rel','response_extremos')" />
            Prompt 8 — RESPONSE: mejores y peores resultados
          </label>
        </div>
      </div>

      <div class="status small" id="modeStatus">
        Primero sube un CSV en la sección 1. Luego se activarán aquí los tipos de análisis compatibles.
      </div>
    </div>

    <!-- Pregunta / Prompt -->
    <div>
      <div class="section-title">3. Prompt de análisis</div>
      <label for="question">
        El prompt se rellenará automáticamente según el análisis elegido, pero puedes editarlo libremente
        antes de ejecutar el cálculo.
      </label>
      <textarea id="question" placeholder="Primero sube un CSV y luego elige un tipo de análisis para cargar aquí el texto recomendado…"></textarea>
      <div class="row">
        <button class="btn" type="button" onclick="analizarCSV()">
          4. Analizar CSV
        </button>
      </div>
      <div id="analysisStatus" class="status">
        ⏳ Sube un CSV, elige un tipo de análisis en la sección 2 y luego usa el botón Analizar.
      </div>
    </div>

    <!-- Resultados de cómputo -->
    <div>
      <div class="section-title">5. Resultados numéricos (resumen técnico)</div>
      <div id="numericOutput" class="output-box small">
        // Aquí aparecerán tablas de conteos, máximos por producto, etc.
      </div>
    </div>

    <!-- Explicación en texto continuo -->
    <div>
      <div class="section-title">6. Explicación en texto continuo (respuesta extendida)</div>
      <div id="textOutput" class="output-box">
        // Aquí se generará una explicación automática extensa basada en los resultados y en tu prompt.
      </div>
    </div>
  </div>
  <!-- Lógica: CSV y análisis interno (sin LLM) -->
  <script>
    // -------------------------------------------------------------
    // Estado global
    // -------------------------------------------------------------
    let csvFile = null;
    let csvHeaders = null;
    let analysisMode = null;       // 'comparaciones', 'whiteness', 'resumen', 'response_rel'
    let currentPromptKey = null;   // identifica el prompt específico dentro de cada modo

    // Tipos de análisis detectados como compatibles con el CSV subido
    const tiposDisponibles = {
      comparaciones: false,
      whiteness: false,
      resumen: false,
      response_rel: false
    };

    const whitenessMetrics = [
      "1.2.WI_STw",
      "2.2.WI_GEw",
      "3.2.WI_VOw",
      "4.2.WI_LGw"
    ];

    const csvInputEl   = document.getElementById("csvInput");
    const fileStatusEl = document.getElementById("fileStatus");
    const csvLabelEl   = document.getElementById("csvLabel");
    const modeStatusEl = document.getElementById("modeStatus");

    // -------------------------------------------------------------
    // Utilidad: actualizar visibilidad de grupos de prompts
    // -------------------------------------------------------------
    function actualizarDisponibilidadPrompts() {
      const groupCompar = document.getElementById("group_comparaciones");
      const groupWhite  = document.getElementById("group_whiteness");
      const groupRes    = document.getElementById("group_resumen");
      const groupResp   = document.getElementById("group_response_rel");

      // Comparaciones
      if (tiposDisponibles.comparaciones) {
        groupCompar.classList.remove("hidden");
      } else {
        groupCompar.classList.add("hidden");
      }

      // Blancura
      if (tiposDisponibles.whiteness) {
        groupWhite.classList.remove("hidden");
      } else {
        groupWhite.classList.add("hidden");
      }

      // Resumen (siempre que el CSV tenga al menos una columna)
      if (tiposDisponibles.resumen) {
        groupRes.classList.remove("hidden");
      } else {
        groupRes.classList.add("hidden");
      }

      // RESPONSE vs otras columnas (solo si existe RESPONSE)
      if (tiposDisponibles.response_rel) {
        groupResp.classList.remove("hidden");
      } else {
        groupResp.classList.add("hidden");
      }

      // Mensaje de ayuda
      const activos = [];
      if (tiposDisponibles.comparaciones) activos.push("Comparaciones PRODUCT_TEST vs RESPONSE");
      if (tiposDisponibles.whiteness)     activos.push("Blancura por MONITOR (métricas WI)");
      if (tiposDisponibles.resumen)      activos.push("Resumen general / avanzado");
      if (tiposDisponibles.response_rel) activos.push("RESPONSE vs otras columnas");

      if (!csvFile) {
        modeStatusEl.textContent =
          "Primero sube un CSV en la sección 1. Luego se activarán aquí los tipos de análisis compatibles.";
      } else if (!activos.length) {
        modeStatusEl.textContent =
          "CSV cargado, pero no se detectó ninguna configuración estándar de análisis. Solo será posible un resumen básico.";
      } else {
        modeStatusEl.textContent =
          "CSV cargado. Tipos de análisis disponibles: " + activos.join(" • ") +
          ". Elige uno para que se cargue el prompt recomendado en la sección 3.";
      }
    }

    // Inicializar (sin CSV aún)
    actualizarDisponibilidadPrompts();

    // -------------------------------------------------------------
    // Manejo de subida de archivo (detecta tipos compatibles)
    // -------------------------------------------------------------
    csvInputEl.addEventListener("change", (ev) => {
      const file = ev.target.files && ev.target.files[0];

      // Limpiar selección de modo al cambiar de CSV
      analysisMode = null;
      currentPromptKey = null;
      document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });

      const questionEl = document.getElementById("question");
      questionEl.value = "";
      questionEl.placeholder =
        "Tras subir el CSV y elegir un tipo de análisis compatible, aquí se cargará el prompt recomendado…";

      if (!file) {
        csvFile = null;
        csvHeaders = null;
        fileStatusEl.textContent = "⚠️ Ningún archivo seleccionado.";
        tiposDisponibles.comparaciones = false;
        tiposDisponibles.whiteness = false;
        tiposDisponibles.resumen = false;
        tiposDisponibles.response_rel = false;
        actualizarDisponibilidadPrompts();
        return;
      }

      fileStatusEl.textContent =
        "⏳ Leyendo archivo: " + file.name + " (" + formatBytes(file.size) + ")…";

      Papa.parse(file, {
        header: true,
        preview: 5,
        skipEmptyLines: true,
        complete: function(results) {
          const headers = results.meta && results.meta.fields ? results.meta.fields : [];
          csvHeaders = headers;

          // Detectar compatibilidad para cada modo usando la misma lógica interna
          const validCompar   = validarHeadersPorModo("comparaciones", headers);
          const validWhite    = validarHeadersPorModo("whiteness", headers);
          const validResumen  = validarHeadersPorModo("resumen", headers);
          const validRespRel  = validarHeadersPorModo("response_rel", headers);

          tiposDisponibles.comparaciones = !!validCompar.ok;
          tiposDisponibles.whiteness     = !!validWhite.ok;
          tiposDisponibles.resumen       = !!validResumen.ok;
          tiposDisponibles.response_rel  = !!validRespRel.ok;

          csvFile = file;

          const disponibles = [];
          if (validCompar.ok)  disponibles.push("Comparación PRODUCT_TEST vs RESPONSE");
          if (validWhite.ok)   disponibles.push("Blancura por MONITOR (métricas WI)");
          if (validRespRel.ok) disponibles.push("RESPONSE vs otras columnas");
          if (validResumen.ok) disponibles.push("Resumen general / avanzado");

          fileStatusEl.textContent =
            "✅ CSV cargado: " + file.name + " (" + formatBytes(file.size) + "). " +
            (disponibles.length
              ? "Análisis posibles: " + disponibles.join(" • ") + "."
              : "Solo será posible un resumen básico de la tabla.");

          csvLabelEl.textContent =
            "Archivo CSV cargado. Si lo deseas, puedes cambiarlo por otro. Ahora elige en la sección 2 el tipo de análisis.";

          actualizarDisponibilidadPrompts();
        },
        error: function(err) {
          csvFile = null;
          csvHeaders = null;
          fileStatusEl.textContent = "❌ Error al leer el CSV: " + err;
          tiposDisponibles.comparaciones = false;
          tiposDisponibles.whiteness = false;
          tiposDisponibles.resumen = false;
          tiposDisponibles.response_rel = false;
          actualizarDisponibilidadPrompts();
        }
      });
    });

    function formatBytes(bytes) {
      if (bytes === 0) return "0 B";
      const k = 1024;
      const sizes = ["B","KB","MB","GB","TB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
    }

    // -------------------------------------------------------------
    // Validación de columnas según modo
    // -------------------------------------------------------------
    function validarHeadersPorModo(mode, headers) {
      const hdr = headers || [];
      const set = new Set(hdr);

      if (mode === "comparaciones") {
        const needed = ["PRODUCT_TEST", "RESPONSE"];
        const faltantes = needed.filter(c => !set.has(c));
        if (faltantes.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas requeridas (" + faltantes.join(", ") +
                     "). Revisa que sea el CSV de comparaciones (PRODUCT_TEST / RESPONSE)."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "whiteness") {
        const base = ["MONITOR", "PRODUCT"];
        const faltantesBase = base.filter(c => !set.has(c));
        if (faltantesBase.length > 0) {
          return {
            ok: false,
            mensaje: "faltan columnas base " + faltantesBase.join(", ") +
                     " para análisis de blancura (MONITOR / PRODUCT)."
          };
        }
        const algunaMetrica = whitenessMetrics.some(m => set.has(m));
        if (!algunaMetrica) {
          return {
            ok: false,
            mensaje: "no se encontró ninguna de las métricas de blancura esperadas: " +
                     whitenessMetrics.join(", ") + "."
          };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "resumen") {
        // Acepta cualquier CSV con al menos una columna
        if (!hdr.length) {
          return { ok: false, mensaje: "el CSV no tiene columnas detectables." };
        }
        return { ok: true, mensaje: "" };
      }

      if (mode === "response_rel") {
        // Necesita al menos la columna RESPONSE
        if (!set.has("RESPONSE")) {
          return {
            ok: false,
            mensaje: "no se encuentra la columna RESPONSE, necesaria para este análisis."
          };
        }
        return { ok: true, mensaje: "" };
      }

      return { ok: false, mensaje: "modo de análisis no reconocido." };
    }

    // -------------------------------------------------------------
    // Selección de prompt interno (sección 2)
    // -------------------------------------------------------------
    function setModeInternal(mode, promptKey) {
      // Debe existir un CSV primero
      if (!csvFile) {
        modeStatusEl.textContent =
          "⚠️ Primero sube un CSV en la sección 1. Después podrás elegir el tipo de análisis.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      // Verificar que el modo es compatible con el CSV actual
      if (mode === "comparaciones" && !tiposDisponibles.comparaciones) {
        modeStatusEl.textContent =
          "❌ El archivo cargado no tiene las columnas necesarias para análisis de Comparaciones (PRODUCT_TEST / RESPONSE).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "whiteness" && !tiposDisponibles.whiteness) {
        modeStatusEl.textContent =
          "❌ El archivo cargado no corresponde a un formato de Blancura (MONITOR, PRODUCT y métricas WI).";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "resumen" && !tiposDisponibles.resumen) {
        modeStatusEl.textContent =
          "❌ El archivo no parece tener estructura válida para un resumen general.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }
      if (mode === "response_rel" && !tiposDisponibles.response_rel) {
        modeStatusEl.textContent =
          "❌ El archivo cargado no contiene la columna RESPONSE, necesaria para este análisis.";
        document.querySelectorAll('input[name="mode"]').forEach(r => { r.checked = false; });
        return;
      }

      analysisMode = mode;
      currentPromptKey = promptKey || mode;

      const questionEl = document.getElementById("question");
      questionEl.placeholder =
        "Prompt oficial cargado para el análisis elegido. Puedes ajustarlo si lo deseas…";

      // --- TEXTOS DE LOS PROMPTS SEGÚN MODO + VARIANTE ---
      if (mode === "comparaciones") {
        if (currentPromptKey === "comparaciones_basico") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv para identificar cuál es el producto con mejor desempeño general. Para ello, toma en cuenta únicamente las comparaciones en las que la columna RESPONSE tenga los valores 01.SUPERIOR o 02.SUPERIOR_TREND, que indican un resultado favorable para PRODUCT_TEST frente a PRODUCT_BENCH. Evalúa cuántas veces cada valor de PRODUCT_TEST alcanza un resultado superior en todas las combinaciones posibles de las columnas MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. El producto que más veces obtenga resultados favorables según estos dos valores de RESPONSE debe ser considerado como el de mejor desempeño. La conclusión debe presentarse en texto continuo, indicando claramente cuál es el producto con mejor rendimiento y por qué, basándose en la frecuencia con la que obtiene un desempeño superior en las comparaciones.`;
        } else if (currentPromptKey === "comparaciones_escenarios") {
          questionEl.value =
`Analiza el archivo OUTPUT_MAP_COMPARISONS.csv poniendo el foco en cómo cambia el desempeño de los distintos PRODUCT_TEST según las columnas MODALITY, SCENARIOS, WASH y PROCESS. Identifica para cada una de estas columnas qué productos tienden a concentrar más respuestas 01.SUPERIOR y 02.SUPERIOR_TREND, señalando si hay formulaciones especialmente fuertes en determinados escenarios o modalidades y si existen contextos donde el rendimiento se reparte de forma más equilibrada. La explicación debe ser en texto continuo, resaltando las combinaciones producto–escenario más robustas y aquellas donde las diferencias entre productos parecen menos marcadas.`;
        }
      } else if (mode === "whiteness") {
        if (currentPromptKey === "whiteness_basico") {
          questionEl.value =
`Para cada uno de los valores únicos de la columna "MONITOR", identifica cuáles son los productos ("PRODUCT") que presentan los valores más altos en cada una de las métricas de blancura: "1.2.WI_STw" (blancura estándar), "2.2.WI_GEw" (blancura verdosa), "3.2.WI_VOw" (blancura violácea) y "4.2.WI_LGw" (blancura luminosa). Para cada caso, indica en qué combinaciones específicas de las variables "MODALITY", "SCENARIOS", "WASH" y "PROCESS" se presentan esos valores máximos. Luego, compara entre los distintos productos dentro de cada tipo de monitor, resaltando si algún producto se destaca de forma consistente en más de una métrica o en múltiples combinaciones. Finalmente, resume qué productos muestran un mejor desempeño global de blancura en función del tipo de monitor utilizado, considerando la frecuencia con la que aparecen con los valores más altos y la diversidad de condiciones en las que lo hacen.`;
        } else if (currentPromptKey === "whiteness_productos") {
          questionEl.value =
`Utiliza los datos de blancura del CSV para construir un perfil de cada "PRODUCT" en términos de las métricas "1.2.WI_STw", "2.2.WI_GEw", "3.2.WI_VOw" y "4.2.WI_LGw" a través de todos los "MONITOR" disponibles. Describe en texto continuo qué productos se ubican con mayor frecuencia en los valores máximos de blancura, cuáles parecen más equilibrados entre varias métricas y cuáles destacan solo en una dimensión específica (por ejemplo, más verdosa o más luminosa). Indica también si hay productos que cambian mucho su posición relativa según el monitor utilizado, y qué implicaciones tiene esto para la lectura global de blancura.`;
        }
      } else if (mode === "resumen") {
        if (currentPromptKey === "resumen_basico") {
          questionEl.value =
`Haz un resumen general de la tabla del CSV, describiendo cuántas filas y columnas contiene, qué tipo de información parece dominar (columnas numéricas frente a categóricas) y cómo se distribuyen los valores. Menciona, de forma interpretativa, cuáles son las columnas que parecen más relevantes o más variadas y qué patrones generales se pueden intuir solamente a partir de los recuentos y de los rangos de valores. La explicación debe ir en texto continuo, sin listas, destacando las ideas principales sobre la estructura y el contenido de la tabla.`;
        } else if (currentPromptKey === "resumen_avanzado") {
          questionEl.value =
`Elabora un resumen avanzado de la tabla combinando la descripción estructural (número de filas, columnas y tipos de variables) con una lectura más interpretativa de qué grupos de columnas parecen estar relacionados entre sí. Sin realizar inferencias causales, comenta qué bloques de variables pueden agruparse (por ejemplo, columnas de contexto experimental frente a columnas de resultados) y cómo podrían utilizarse en análisis posteriores más específicos. La explicación debe ser narrativa, destacando las conexiones más plausibles sólo a partir de la estructura y de los recuentos.`;
        }
      } else if (mode === "response_rel") {
        if (currentPromptKey === "response_basico") {
          questionEl.value =
`Compara la distribución de los valores de la columna RESPONSE con lo que ocurre en el resto de columnas del CSV. Identifica qué valores de RESPONSE son más frecuentes y, para cada uno de ellos, describe qué patrones se observan en las columnas principales (productos, monitores, modalidades, escenarios, procesos, etc.). Explica de forma narrativa si hay combinaciones de valores que aparezcan más asociadas a determinados resultados de RESPONSE, resaltando las tendencias más claras que puedan deducirse únicamente de los recuentos.`;
        } else if (currentPromptKey === "response_extremos") {
          questionEl.value =
`Profundiza en la columna RESPONSE distinguiendo claramente entre los resultados más favorables y los menos favorables. Para cada grupo (por ejemplo, valores que representan superioridad, empate o inferioridad), describe qué patrones se observan en las columnas de producto, monitor, modalidad y escenario. Explica en texto continuo qué combinaciones parecen asociarse con respuestas especialmente buenas y cuáles tienden a concentrar los peores resultados, utilizando únicamente recuentos y frecuencias obtenidos del CSV.`;
        }
      }

      let modoTexto = "";
      if (mode === "comparaciones") modoTexto = "Comparación PRODUCT_TEST vs RESPONSE.";
      else if (mode === "whiteness") modoTexto = "Blancura por MONITOR (métricas WI).";
      else if (mode === "resumen") modoTexto = "Resumen general / avanzado de la tabla.";
      else if (mode === "response_rel") modoTexto = "Comparar RESPONSE con las demás columnas.";

      modeStatusEl.textContent =
        "✅ Prompt interno seleccionado: " + modoTexto;
    }

    window.setMode = setModeInternal;

    // -------------------------------------------------------------
    // Botón principal: analizar CSV
    // -------------------------------------------------------------
    function analizarCSVInternal() {
      const statusEl = document.getElementById("analysisStatus");
      const numericEl = document.getElementById("numericOutput");
      const textEl = document.getElementById("textOutput");
      const question = document.getElementById("question").value.trim();

      if (!csvFile) {
        statusEl.textContent = "⚠️ Sube primero el archivo CSV en la sección 1.";
        return;
      }
      if (!analysisMode) {
        statusEl.textContent = "⚠️ Elige un tipo de análisis en la sección 2.";
        return;
      }

      statusEl.textContent = "⏳ Analizando CSV en modo: " +
        (analysisMode === "whiteness"
          ? "BLANCURA"
          : analysisMode === "comparaciones"
            ? "COMPARACIONES"
            : analysisMode === "resumen"
              ? "RESUMEN GENERAL / AVANZADO"
              : "RESPONSE vs OTRAS COLUMNAS") + "…";

      numericEl.textContent = "// Procesando CSV, esto puede tardar para archivos grandes…";
      textEl.textContent = "// Preparando explicación…";

      if (analysisMode === "whiteness") {
        analizarBlancura(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "comparaciones") {
        analizarComparaciones(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "resumen") {
        analizarResumen(statusEl, numericEl, textEl, question);
      } else if (analysisMode === "response_rel") {
        analizarResponseVsOtros(statusEl, numericEl, textEl, question);
      }
    }

    window.analizarCSV = analizarCSVInternal;

    // -------------------------------------------------------------
    // Modo 1: Comparaciones PRODUCT_TEST vs RESPONSE
    // -------------------------------------------------------------
    function analizarComparaciones(statusEl, numericEl, textEl, userPrompt) {
      const objetivos = new Set(["01.SUPERIOR", "02.SUPERIOR_TREND"]);
      const conteos = {};
      let totalFilas = 0;
      let totalFiltradas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const resp = (row["RESPONSE"] || "").trim();
            if (objetivos.has(resp)) {
              totalFiltradas++;
              const ptest = (row["PRODUCT_TEST"] || "").trim() || "(VACÍO)";
              conteos[ptest] = (conteos[ptest] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (Object.keys(conteos).length === 0) {
            statusEl.textContent = "❌ No se encontraron filas con RESPONSE = 01.SUPERIOR o 02.SUPERIOR_TREND.";
            numericEl.textContent = "// Sin resultados favorables para PRODUCT_TEST.";
            textEl.textContent = "// No hay suficientes datos favorables para generar una conclusión.";
            return;
          }

          const ordenados = Object.entries(conteos).sort((a,b) => b[1] - a[1]);
          const totalFavorables = ordenados.reduce((s, [,c]) => s + c, 0);

          let numTxt = "";
          numTxt += "Total de filas leídas: " + totalFilas + "\n";
          numTxt += "Filas con RESPONSE en {01.SUPERIOR, 02.SUPERIOR_TREND}: " + totalFiltradas + "\n\n";
          numTxt += "Conteo de resultados favorables por PRODUCT_TEST:\n";
          for (const [prod, cnt] of ordenados) {
            const pct = totalFavorables > 0 ? (cnt * 100 / totalFavorables).toFixed(2) + "%" : "–";
            numTxt += "  - " + prod + ": " + cnt + " (" + pct + " de los favorables)\n";
          }
          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaComparaciones(
            userPrompt,
            ordenados,
            totalFilas,
            totalFiltradas,
            totalFavorables
          );

          statusEl.textContent = "✅ Análisis de comparaciones completado.";
        },
        error: function(err) {
          statusEl.textContent = "❌ Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaComparaciones(
      userPrompt,
      ordenados,
      totalFilas,
      totalFiltradas,
      totalFavorables
    ) {
      const [prodGanador, cntGanador] = ordenados[0];
      const pctGanador = totalFavorables > 0 ? (cntGanador * 100 / totalFavorables).toFixed(1) : null;
      const otros = ordenados.slice(1, Math.min(6, ordenados.length));
      const promptIntro = userPrompt
        ? "La pregunta planteada por el usuario fue la siguiente: «" +
          userPrompt.replace(/\s+/g, " ").trim() +
          "». A partir de esta petición, el análisis se centra en estudiar el comportamiento de PRODUCT_TEST frente a PRODUCT_BENCH utilizando únicamente las filas del CSV donde la respuesta indica una superioridad clara.\n\n"
        : "En este análisis se ha considerado la información contenida en el archivo de comparaciones, enfocándose en las filas donde la respuesta indica un desempeño superior para PRODUCT_TEST frente a PRODUCT_BENCH.\n\n";

      let texto = "";

      texto += promptIntro;
      texto += "El archivo incluye un total de " + totalFilas + " filas, pero para evaluar el desempeño real de los productos se filtraron únicamente aquellos casos en los que la columna RESPONSE toma los valores 01.SUPERIOR o 02.SUPERIOR_TREND. ";
      texto += "Tras este filtrado, quedaron " + totalFiltradas + " observaciones que pueden considerarse evidencias de superioridad o tendencia a la superioridad. ";
      texto += "A partir de este conjunto depurado se contabilizó cuántas veces cada valor de PRODUCT_TEST aparece asociado a un resultado favorable, agrupando todos los escenarios de MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD para tener una visión global.\n\n";

      texto += "Los resultados muestran que el producto que más veces alcanza un resultado favorable es «" + prodGanador + "», con " + cntGanador + " ocurrencias. ";
      if (pctGanador !== null) {
        texto += "Si se compara este número con el total de casos favorables, «" + prodGanador + "» concentra aproximadamente el " + pctGanador + "% de todas las situaciones en las que algún producto gana frente al benchmark. ";
      }
      texto += "Este nivel de presencia indica que «" + prodGanador + "» tiende a repetir este comportamiento a lo largo de diversas combinaciones de condiciones de lavado, tipo de tejido, escenario de suciedad, monitor de evaluación y umbral de decisión.\n\n";

      if (otros.length > 0) {
        texto += "Cuando se observa el resto de productos, aparecen otras formulaciones que logran también un número significativo de victorias, aunque siempre por debajo de «" + prodGanador + "». ";
        texto += "Entre los principales competidores se encuentran:\n\n";

        otros.forEach(([prod, cnt]) => {
          const pct = totalFavorables > 0 ? (cnt * 100 / totalFavorables).toFixed(1) : null;
          texto += "• «" + prod + "» con " + cnt + " resultados favorables";
          if (pct !== null) {
            texto += ", lo que representa aproximadamente el " + pct + "% del total de casos favorables";
          }
          texto += ".\n";
        });
        texto += "\n";
      }

      texto += "Más allá del simple conteo de victorias, es importante considerar la diversidad de contextos en los que se produce la superioridad. ";
      texto += "Cada fila corresponde a una combinación específica de MODALITY, SCENARIOS, WASH, PROCESS, MONITOR, INDEX y THRESHOLD. ";
      texto += "Que un producto aparezca repetidamente como superior sugiere que su formulación es robusta frente a cambios en estas variables.\n\n";

      texto += "En resumen, considerando exclusivamente las filas en las que PRODUCT_TEST demuestra superioridad frente a PRODUCT_BENCH, ";
      texto += "el análisis pone de manifiesto que «" + prodGanador + "» es el producto con mejor desempeño global en términos de frecuencia de victorias y potencial robustez a través de distintos escenarios.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 2: Blancura por MONITOR
    // -------------------------------------------------------------
    function analizarBlancura(statusEl, numericEl, textEl, userPrompt) {
      const data = {};
      let totalFilas = 0;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          for (const row of rows) {
            totalFilas++;
            const monitor = (row["MONITOR"] || "").trim();
            const product = (row["PRODUCT"] || "").trim();
            if (!monitor || !product) continue;

            for (const m of whitenessMetrics) {
              if (!(m in row)) continue;
              const v = parseFloat(row[m]);
              if (Number.isNaN(v)) continue;

              if (!data[monitor]) data[monitor] = {};
              if (!data[monitor][m]) data[monitor][m] = { max: null, rows: [] };

              const entry = data[monitor][m];
              if (entry.max === null || v > entry.max) {
                entry.max = v;
                entry.rows = [{
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                }];
              } else if (v === entry.max) {
                entry.rows.push({
                  PRODUCT: product,
                  MODALITY: row["MODALITY"] || "",
                  SCENARIOS: row["SCENARIOS"] || "",
                  WASH: row["WASH"] || "",
                  PROCESS: row["PROCESS"] || "",
                  VALUE: v
                });
              }
            }
          }
        },
        complete: function() {
          if (!Object.keys(data).length) {
            statusEl.textContent = "❌ No se encontraron datos válidos de blancura por MONITOR.";
            numericEl.textContent = "// Sin resultados de métricas de blancura.";
            textEl.textContent = "// No hay suficientes datos de blancura para generar una conclusión.";
            return;
          }

          const globalCounts = {};
          for (const monitor of Object.keys(data)) {
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              for (const row of info.rows) {
                const prod = row.PRODUCT || "(VACÍO)";
                globalCounts[prod] = (globalCounts[prod] || 0) + 1;
              }
            }
          }

          let numTxt = "";
          numTxt += "Total de filas leídas: " + totalFilas + "\n\n";
          numTxt += "Máximos de blancura por MONITOR y métrica:\n";
          for (const monitor of Object.keys(data).sort()) {
            numTxt += "MONITOR = " + monitor + "\n";
            const metricsObj = data[monitor];
            for (const metric of Object.keys(metricsObj)) {
              const info = metricsObj[metric];
              numTxt += "  Métrica: " + metric + ", valor máximo: " + info.max + "\n";
              for (const row of info.rows) {
                numTxt += "    - PRODUCT = " + row.PRODUCT +
                          ", MODALITY = " + row.MODALITY +
                          ", SCENARIOS = " + row.SCENARIOS +
                          ", WASH = " + row.WASH +
                          ", PROCESS = " + row.PROCESS + "\n";
              }
            }
            numTxt += "\n";
          }

          numTxt += "Conteo global de apariciones como máximo de blancura por PRODUCT:\n";
          const globalSorted = Object.entries(globalCounts).sort((a,b) => b[1] - a[1]);
          for (const [prod, cnt] of globalSorted) {
            numTxt += "  - " + prod + ": " + cnt + "\n";
          }

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaBlancura(userPrompt, data, globalSorted);

          statusEl.textContent = "✅ Análisis de blancura completado.";
        },
        error: function(err) {
          statusEl.textContent = "❌ Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaBlancura(userPrompt, data, globalSorted) {
      if (!globalSorted.length) {
        return "// No se pudieron construir patrones globales de blancura.";
      }
      const [prodTop, cntTop] = globalSorted[0];
      const promptIntro = userPrompt
        ? "El análisis de blancura se ha guiado por la siguiente pregunta o enfoque: «" +
          userPrompt.replace(/\s+/g, " ").trim() +
          "».\n\n"
        : "En este análisis se ha estudiado el comportamiento de la blancura a partir de los datos del CSV.\n\n";

      let texto = "";
      texto += promptIntro;
      texto += "A partir de las métricas de blancura asociadas a cada MONITOR, se identificaron los valores máximos de las distintas métricas WI en función de las combinaciones de producto, modalidad de lavado, escenario de suciedad y proceso. ";
      texto += "El recuento global de apariciones como máximo de blancura muestra que el producto que más veces lidera es «" + prodTop + "», con " + cntTop + " apariciones entre todas las combinaciones de MONITOR y métricas de blancura consideradas.\n\n";

      texto += "Este patrón sugiere que la formulación asociada a «" + prodTop + "» tiene una capacidad notable para generar niveles elevados de blancura en condiciones variadas. ";
      texto += "Aunque otros productos también alcanzan en ocasiones los valores máximos en determinados monitores o métricas, la frecuencia con la que «" + prodTop + "» aparece como referencia indica una ventaja global en términos de consistencia.\n\n";

      texto += "Al desglosar los resultados por monitor, se observa que cada sistema de evaluación aporta matices distintos: algunos monitores pueden ser más sensibles a diferencias de matiz verdoso o violáceo, mientras que otros ponen más énfasis en la blancura luminosa o estándar. ";
      texto += "El hecho de que un mismo producto destaque repetidamente en diferentes monitores y métricas refuerza la idea de una blancura percibida más sólida en un rango amplio de condiciones.\n\n";

      texto += "En conjunto, y siempre dentro de los límites del CSV analizado, los datos apuntan a que «" + prodTop + "» ofrece un mejor desempeño global cuando se consideran simultáneamente los distintos monitores y las métricas de blancura estudiadas. ";
      texto += "Otros productos pueden mostrar picos de rendimiento en contextos concretos, pero ninguno parece igualar la combinación de frecuencia y diversidad de situaciones en las que «" + prodTop + "» se sitúa en la parte alta del ranking de blancura.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 3: Resumen general de la tabla
    // -------------------------------------------------------------
    function analizarResumen(statusEl, numericEl, textEl, userPrompt) {
      const stats = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            for (const col of Object.keys(row)) {
              if (!stats[col]) {
                stats[col] = {
                  numericCount: 0,
                  nonNumericCount: 0,
                  sum: 0,
                  min: null,
                  max: null,
                  categories: {}
                };
              }
              const valRaw = row[col];
              if (valRaw === null || valRaw === undefined) continue;
              const val = String(valRaw).trim();
              if (val === "") continue;

              const num = parseFloat(val.replace(",", "."));
              if (!Number.isNaN(num) && val.match(/^[+-]?(\d+(\.\d+)?|\.\d+)$/)) {
                // Numérico "limpio"
                stats[col].numericCount++;
                stats[col].sum += num;
                if (stats[col].min === null || num < stats[col].min) stats[col].min = num;
                if (stats[col].max === null || num > stats[col].max) stats[col].max = num;
              } else {
                stats[col].nonNumericCount++;
                stats[col].categories[val] = (stats[col].categories[val] || 0) + 1;
              }
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "❌ No se pudo detectar estructura válida en el CSV.";
            numericEl.textContent = "// Sin información estructural disponible.";
            textEl.textContent = "// No hay suficiente información para generar un resumen.";
            return;
          }

          const numCols = headersLocal.length;
          let numTxt = "";
          numTxt += "Total de filas leídas: " + totalFilas + "\n";
          numTxt += "Total de columnas detectadas: " + numCols + "\n\n";

          numTxt += "Resumen por columna:\n";
          headersLocal.forEach(col => {
            const s = stats[col] || {
              numericCount: 0, nonNumericCount: 0,
              sum: 0, min: null, max: null, categories: {}
            };
            const esNumerica = s.numericCount > 0 && s.nonNumericCount === 0;
            numTxt += "Columna: " + col + "\n";
            if (esNumerica) {
              const mean = s.numericCount > 0 ? (s.sum / s.numericCount) : null;
              numTxt += "  Tipo: numérica\n";
              numTxt += "  Valores válidos: " + s.numericCount + "\n";
              if (s.min !== null && s.max !== null) {
                numTxt += "  Rango aproximado: [" + s.min + ", " + s.max + "]\n";
              }
              if (mean !== null) {
                numTxt += "  Promedio aproximado: " + mean + "\n";
              }
            } else {
              const cats = Object.entries(s.categories);
              numTxt += "  Tipo: categórica / mixta\n";
              numTxt += "  Valores no vacíos: " + (s.numericCount + s.nonNumericCount) + "\n";
              numTxt += "  Nº de categorías distintas: " + cats.length + "\n";
              if (cats.length) {
                const topCats = cats.sort((a,b) => b[1]-a[1]).slice(0,5);
                numTxt += "  Categorías más frecuentes:\n";
                topCats.forEach(([v,c]) => {
                  numTxt += "    - " + v + " (" + c + " ocurrencias)\n";
                });
              }
            }
            numTxt += "\n";
          });

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaResumen(
            userPrompt,
            totalFilas,
            headersLocal,
            stats
          );

          statusEl.textContent = "✅ Resumen general / avanzado completado.";
        },
        error: function(err) {
          statusEl.textContent = "❌ Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaResumen(userPrompt, totalFilas, headersLocal, stats) {
      const promptIntro = userPrompt
        ? "El resumen se ha elaborado tomando como referencia la siguiente instrucción: «" +
          userPrompt.replace(/\s+/g," ").trim() + "».\n\n"
        : "A continuación se presenta un resumen general de la estructura y el contenido del CSV analizado.\n\n";

      let texto = "";
      texto += promptIntro;
      texto += "La tabla analizada contiene un total de " + totalFilas + " filas y " +
               headersLocal.length + " columnas, lo que ya sugiere un volumen de información suficiente como para identificar patrones y variaciones entre distintos campos.\n\n";

      // Clasificar columnas numéricas vs categóricas/mixtas
      const colsNumericas = [];
      const colsCateg = [];
      headersLocal.forEach(col => {
        const s = stats[col];
        if (!s) return;
        const esNumerica = s.numericCount > 0 && s.nonNumericCount === 0;
        if (esNumerica) colsNumericas.push(col);
        else colsCateg.push(col);
      });

      if (colsNumericas.length > 0) {
        texto += "En cuanto a variables numéricas, se identifican columnas como ";
        texto += "«" + colsNumericas.slice(0,4).join("», «") + "»";
        if (colsNumericas.length > 4) {
          texto += " y otras más, que completan un conjunto de " + colsNumericas.length + " columnas de carácter cuantitativo. ";
        } else {
          texto += ", que en conjunto conforman el núcleo de información numérica de la tabla. ";
        }
        texto += "Estas columnas permiten estimar rangos, promedios y posibles diferencias entre productos, escenarios o procesos, según la naturaleza específica de cada campo.\n\n";
      }

      if (colsCateg.length > 0) {
        texto += "Por el lado de las variables categóricas o mixtas, aparecen columnas como ";
        texto += "«" + colsCateg.slice(0,4).join("», «") + "»";
        if (colsCateg.length > 4) {
          texto += " y varias más, que aportan etiquetas y clasificaciones clave para interpretar los resultados numéricos. ";
        } else {
          texto += ", que sirven como ejes de segmentación para organizar la información de la tabla. ";
        }
        texto += "En estas columnas suelen concentrarse códigos de producto, tipos de monitor, modalidades de lavado, escenarios de suciedad o procesos, lo que permite dividir la información en grupos comparables.\n\n";
      }

      texto += "Si se observa el comportamiento interno de cada columna, se aprecia que algunas presentan una gran diversidad de categorías, mientras que otras se concentran en unos pocos valores recurrentes. ";
      texto += "Las columnas con muchas categorías distintas pueden estar capturando una variedad amplia de situaciones o combinaciones experimentales, mientras que aquellas con pocos valores dominantes indican focos claros de interés o configuraciones repetidas a lo largo del experimento.\n\n";

      texto += "En términos generales, la estructura de la tabla ofrece un equilibrio entre campos numéricos y categóricos, lo que facilita la construcción de indicadores agregados (promedios, máximos, rangos) y, al mismo tiempo, la segmentación por tipo de producto, monitor o escenario. ";
      texto += "Este equilibrio es especialmente útil en contextos de evaluación comparativa, donde no solo importa el valor numérico aislado, sino también el contexto experimental en el que se obtiene.\n\n";

      texto += "De este modo, el CSV no solo actúa como un contenedor de resultados, sino como un mapa donde cada columna añade una capa distinta de significado: unas cuantifican el desempeño, otras describen las condiciones de prueba y otras organizan las observaciones en familias coherentes. ";
      texto += "La combinación de todas ellas permite construir lecturas más ricas sobre el comportamiento de los productos y sobre cómo cambian los resultados al modificar los distintos factores del experimento.\n";

      return texto;
    }

    // -------------------------------------------------------------
    // Modo 4: Comparar RESPONSE con las demás columnas
    // -------------------------------------------------------------
    function analizarResponseVsOtros(statusEl, numericEl, textEl, userPrompt) {
      const responseCounts = {};
      const responseColumnCounts = {};
      let totalFilas = 0;
      let headersLocal = null;

      Papa.parse(csvFile, {
        header: true,
        skipEmptyLines: true,
        worker: false,
        chunkSize: 1024 * 1024,
        chunk: function(results) {
          const rows = results.data;
          if (!headersLocal) {
            headersLocal = results.meta && results.meta.fields ? results.meta.fields : [];
          }
          for (const row of rows) {
            totalFilas++;
            const rRaw = row["RESPONSE"];
            const resp = (rRaw === undefined || rRaw === null || String(rRaw).trim() === "")
              ? "(VACÍO)" : String(rRaw).trim();
            responseCounts[resp] = (responseCounts[resp] || 0) + 1;

            for (const col of headersLocal) {
              if (col === "RESPONSE") continue;
              const vRaw = row[col];
              const val = (vRaw === undefined || vRaw === null || String(vRaw).trim() === "")
                ? "(VACÍO)" : String(vRaw).trim();

              if (!responseColumnCounts[col]) responseColumnCounts[col] = {};
              if (!responseColumnCounts[col][resp]) responseColumnCounts[col][resp] = {};
              responseColumnCounts[col][resp][val] =
                (responseColumnCounts[col][resp][val] || 0) + 1;
            }
          }
        },
        complete: function() {
          if (!headersLocal || !headersLocal.length) {
            statusEl.textContent = "❌ No se pudo detectar estructura válida en el CSV.";
            numericEl.textContent = "// Sin información estructural disponible.";
            textEl.textContent = "// No hay suficiente información para analizar RESPONSE.";
            return;
          }

          const sortedResponses = Object.entries(responseCounts).sort((a,b) => b[1]-a[1]);

          let numTxt = "";
          numTxt += "Total de filas leídas: " + totalFilas + "\n\n";
          numTxt += "Distribución de la columna RESPONSE:\n";
          sortedResponses.forEach(([r,c]) => {
            const pct = totalFilas > 0 ? (c*100/totalFilas).toFixed(2) + "%" : "–";
            numTxt += "  - " + r + ": " + c + " filas (" + pct + ")\n";
          });
          numTxt += "\n";

          numTxt += "Asociaciones entre RESPONSE y el resto de columnas (primeras 6 columnas distintas de RESPONSE):\n";
          const colsAnalizar = headersLocal.filter(c => c !== "RESPONSE").slice(0,6);

          const resumenColumnas = [];

          colsAnalizar.forEach(col => {
            const byResp = responseColumnCounts[col] || {};
            numTxt += "\nColumna: " + col + "\n";
            const perResponseTop = {};
            sortedResponses.forEach(([resp, _cntR]) => {
              const mapaValores = byResp[resp];
              if (!mapaValores) return;
              const sortedVals = Object.entries(mapaValores).sort((a,b) => b[1]-a[1]).slice(0,3);
              if (!sortedVals.length) return;
              perResponseTop[resp] = sortedVals;

              numTxt += "  RESPONSE = " + resp + ":\n";
              sortedVals.forEach(([v,c]) => {
                numTxt += "    - " + v + " (" + c + " filas)\n";
              });
            });
            resumenColumnas.push({ columna: col, perResponseTop });
          });

          numericEl.textContent = numTxt;

          textEl.textContent = construirExplicacionLargaResponseRel(
            userPrompt,
            totalFilas,
            sortedResponses,
            resumenColumnas
          );

          statusEl.textContent = "✅ Análisis RESPONSE vs otras columnas completado.";
        },
        error: function(err) {
          statusEl.textContent = "❌ Error al leer el CSV: " + err;
          numericEl.textContent = "// Error al procesar el archivo.";
          textEl.textContent = "";
        }
      });
    }

    function construirExplicacionLargaResponseRel(
      userPrompt,
      totalFilas,
      sortedResponses,
      resumenColumnas
    ) {
      const promptIntro = userPrompt
        ? "El análisis de la relación entre RESPONSE y el resto de columnas se ha guiado por la instrucción: «" +
          userPrompt.replace(/\s+/g," ").trim() + "».\n\n"
        : "En este apartado se explora cómo se distribuye RESPONSE y qué asociaciones se observan con las demás columnas del CSV.\n\n";

      let texto = "";
      texto += promptIntro;

      if (!sortedResponses.length) {
        texto += "En la práctica, no se han encontrado valores informativos en la columna RESPONSE, por lo que no es posible establecer patrones claros frente al resto de columnas.\n";
        return texto;
      }

      const [respTop, cntTop] = sortedResponses[0];
      const pctTop = totalFilas > 0 ? (cntTop*100/totalFilas).toFixed(1) : null;

      texto += "Al observar la distribución general, la columna RESPONSE se reparte en varios valores posibles, pero el que domina con mayor peso es «" + respTop + "», que reúne " + cntTop + " filas";
      if (pctTop !== null) {
        texto += ", lo que equivale aproximadamente al " + pctTop + "% del total de registros";
      }
      texto += ". El resto de valores de RESPONSE aparece con menor frecuencia, conformando una cola de resultados menos habituales que también contribuyen a matizar la lectura global.\n\n";

      if (sortedResponses.length > 1) {
        const segundas = sortedResponses.slice(1,3);
        if (segundas.length) {
          texto += "Además de este valor dominante, se identifican otros resultados de RESPONSE que, aunque menos frecuentes, reúnen un número apreciable de casos. ";
          texto += "Entre ellos destacan ";
          texto += segundas.map(([r,c]) => "«" + r + "» (" + c + " filas)").join(" y ");
          texto += ", que completan el mapa de respuestas posibles en el experimento.\n\n";
        }
      }

      if (!resumenColumnas.length) {
        texto += "Al relacionar RESPONSE con el resto de columnas, no se han encontrado patrones suficientemente claros como para destacar asociaciones específicas, posiblemente debido a la dispersión de los datos o a la diversidad de valores. ";
        texto += "Aun así, la distribución global de RESPONSE ya permite intuir qué resultados se repiten con mayor insistencia en el conjunto de ensayos.\n";
        return texto;
      }

      texto += "Cuando se cruza RESPONSE con otras columnas clave de la tabla, comienzan a aparecer patrones más concretos. ";
      texto += "Cada columna actúa como un eje de segmentación que permite ver qué combinaciones de valores se repiten con mayor frecuencia para cada tipo de respuesta.\n\n";

      const columnasComentadas = resumenColumnas.slice(0,3);
      columnasComentadas.forEach(colInfo => {
        const colName = colInfo.columna;
        const perResponseTop = colInfo.perResponseTop || {};
        texto += "En la columna «" + colName + "», las distribuciones por RESPONSE muestran que:\n";

        const respuestasComentadas = Object.entries(perResponseTop).slice(0,2);
        if (!respuestasComentadas.length) {
          texto += "  No se observan concentraciones claras asociadas a valores específicos de RESPONSE en esta columna.\n\n";
          return;
        }

        respuestasComentadas.forEach(([respVal, topVals]) => {
          if (!topVals || !topVals.length) return;
          const lista = topVals.map(([v,c]) => "«" + v + "» (" + c + " filas)").join(", ");
          texto += "  Para RESPONSE = «" + respVal + "» predominan valores como " + lista + ".\n";
        });
        texto += "\n";
      });

      texto += "En conjunto, estas asociaciones no deben interpretarse como relaciones causales directas, pero sí como indicios de que ciertos contextos (definidos por productos, monitores, modalidades o escenarios) tienden a coincidir con determinados resultados de RESPONSE con mayor frecuencia que otros. ";
      texto += "Esto convierte a RESPONSE en una especie de indicador de salida que resume el efecto combinado de todas esas columnas, y a los patrones detectados en un punto de partida útil para explorar con más detalle qué configuraciones experimentales están detrás de los mejores y peores desempeños.\n";

      return texto;
    }
  </script>
</body>
</html>

